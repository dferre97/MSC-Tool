\subsection{Communicating finite state machines\label{app:cfsm}}
We now recall the definition of communicating systems (aka communicating finite-state
machines or message-passing automata), which consist of finite-state machines $A_p$
(one for every process $p \in \Procs$) that can communicate through channels from $\Ch$.

\begin{definition}\label{def:cs}
A \emph{system of communicating finite state machines} over the set $\Procs$ of rocesses
and the set $\Msg$ of messages is a tuple
   $ \Sys = (A_p)_{p\in\procSet}$. For each
   $p \in \Procs$, $A_p = (Loc_p, \delta_p, \ell^0_p)$ is a finite transition system where
   $\Loc_p$ is a finite set of local (control) states, $\delta_p
   \subseteq \Loc_p \times \pAct{p} \times \Loc_p$ is the
   transition relation, and $\ell^0_p \in Loc_p$ is the initial state.
\end{definition}

Given $p \in \Procs$ and a transition $t = (\ell,a,\ell') \in \delta_p$, we let
$\tsource(t) = \ell$, $\ttarget(t) = \ell'$, $\tlabel(t) = a$, and
$\tmessage(t) = \msg$ if $a \in \msAct{\msg} \cup \mrAct{\msg}$.

% \smallskip

% There are in general two ways to define the semantics of a communicating system.
% Most often it is defined as a global infinite transition system that keeps track
% of the various local control states and all (unbounded) channel contents.
% As, in this paper, our arguments are based on a graph view of MSCs, we will define
% the language of $\Sys$ directly as a set of MSCs. These two semantic views are essentially
% equivalent, but they have different advantages depending on the context.
% We refer to \cite{CyriacG14} for a thorough discussion.

% \davidequestion{MSCs are formally defined in chapter 5... maybe move here in the preliminaries just the asynchronous definition?}

Let $\msc = (\Events,\procrel,\lhd,\lambda)$ be an MSC.
A \emph{run} of $\Sys$ on $\msc$ is a mapping
$\rho: \Events \to \bigcup_{p \in \Procs} \delta_p$
that assigns to every event $e$ the transition $\rho(e)$
that is executed at $e$. Thus, we require that
\begin{enumerate*}[label={(\roman*)}]
\item for all $e \in \Events$, we have $\tlabel(\rho(e)) = \lambda(e)$,
\item for all $(e,f) \in {\procrel}$, $\ttarget(\rho(e)) = \tsource(\rho(f))$,
\item for all $(e,f) \in {\lhd}$, $\tmessage(\rho(e)) = \tmessage(\rho(f))$,
and
\item for all $p \in \Procs$ and $e \in \Events_p$ such that there is no $f \in \Events$ with $f \procrel e$, we have $\tsource(\rho(e)) = \ell_p^0$.
\end{enumerate*}

We write $L_{\asy}(\Sys)$ to denote the set of MSCs $\msc$ that admit a run of $\Sys$.
Intuitively, $L_{\asy}(\Sys)$ is the set of all asynchronous behaviours of $\Sys$.

% Letting run $\Sys$ directly on MSCs is actually very convenient.
% This allows us to associate with $\Sys$ its p2p language and mailbox language
% in one go. The \emph{\pp language} of $\Sys$ is $\ppL{\Sys} = \{\msc \in \ppMSCs \mid$ there is a run of $\Sys$ on $\msc\}$.
% The \emph{mailbox language} of $\Sys$ is $\mbL{\Sys} = \{\msc \in \mbMSCs \mid$ there is a run of $\Sys$ on $\msc\}$.
%
% Note that, following \cite{DBLP:conf/cav/BouajjaniEJQ18,DBLP:conf/fossacs/GiustoLL20},
% we do not consider final states or final configurations, as our purpose is to
% reason about all possible
% traces that can be \emph{generated} by $\Sys$.
% %We will discuss this issue in more detail later in the paper. \todo{Do we still discuss this in the conference version or can we omit this sentence?}

\subsection{Conflict Graph}\label{app:conflict-graph}

\etienne{Copy-paste from a file, not sure how it fits with the rest of the appendix yet.}
\davidequestion{The conflict graph is needed only for some proofs on the cuncur paper. I think it makes sense not to include it here and eventually introduce it later in the MSO-treewidth chapter if we really need it.}

We now recall the notion of a conflict graph associated to an MSC defined in \cite{DBLP:conf/cav/BouajjaniEJQ18}. This graph is used to depict the causal dependencies between message exchanges.  Intuitively, we have a dependency whenever
two messages have a process in common. For instance, an $\xrightarrow{SS}$
dependency between message exchanges $v$ and $v'$ expresses the fact that
$v'$ has been sent after $v$, by the same process. This notion is of interest because it was seen in \cite{DBLP:conf/cav/BouajjaniEJQ18} that the notion of synchronizability in MSCs (which is studied in this paper) can be graphically characterized by the nature of the associated conflict graph.
It is defined in terms of linearizations
in \cite{DBLP:conf/fossacs/GiustoLL20}, but we equivalently express it
directly in terms of MSCs.

For an MSC $\msc = (\Events, \rightarrow, \lhd, \lambda)$ and
$e \in \Events$, we define the type $\type(e) \in \{\stype,\rtype\}$ of $e$ by $\type(e) = \stype$ if $e \in \SendEv{\msc}$
and $\type(e) = \rtype$ if $e \in \RecEv{\msc}$.
Moreover, for $e \in \Unm{\msc}$, we let $\mexch(e) = e$,
and for $(e,e') \in \lhd$, we let $\mexch(e) = \mexch(e') = (e,e')$.


\begin{definition}[Conflict graph]
	The \emph{conflict graph} $\cgraph{\msc}$ of an MSC $\msc = (\Events, \rightarrow, \lhd, \lambda)$ is the labeled graph $(\Nodes, \Edges)$, with $\Edges \subseteq \Nodes \times \{\stype,\rtype\}^2 \times \Nodes$, defined by
	$\Nodes = {\lhd} \cup \Unm{\msc}$ and $\Edges = \{(\mu(e),\type(e)\type(f),\mu(f)) \mid (e,f) \in {\to^+}\}$.
In particular, a node of $\cgraph{\msc}$ is either a single unmatched send event or a message pair $(e,e') \in {\lhd}$.
\end{definition}


\subsection{Proof of Theorem~\ref{thm:bounded-model-checking}}


\thmBoundedMC*

\begin{proof}
   Let $\comsymb$, $\aMSCclass$, $\Sys$, and $\amsoformula$ 
   be fixed. We showed in Section~\ref{sec:MSO} 
   that there is a MSO formula
   $\msoformulaofcom{\comsymb}$
   that defines $\MSCclassofcom{\comsymb}$.
   It is also folklore that there is a MSO formula
   $\amsoformula_{\Sys}$ such that
   $L_{\asy}(\Sys)=L(\amsoformula_{\Sys})$.\footnote{The formula
   simply encodes the existence of a run of $\Sys$ on the MSC
   using a monadic second order variable $X_l$ for each control
   state $l$, with the meaning that $X_l$ is the set of events
   before which the local communicating automaton was in state $l$.}
   Putting it together, we have
    \[\begin{array}{rl}
    &L_{\comsymb}()\System) \cap \stwMSCs{k} \subseteq L(\amsoformula)\\[1ex]
    \Longleftrightarrow &\asyL{\System} \cap \MSCclassofcom{\comsymb} \cap \stwMSCs{k} \subseteq L(\phi)\\[1ex]
    \Longleftrightarrow & L(\amsoformula_{\System}) \cap L(\msoformulaofcom{\comsymb}) \cap \stwMSCs{k} \subseteq L(\phi)\\[1ex]
    \Longleftrightarrow &\stwMSCs{k} \subseteq L(\phi \vee \neg \msoformulaofcom{\comsymb}\vee\neg\amsoformula_{\System})\,.
    \end{array}\]

    The latter is decidable by Courcelle's theorem~\cite{Courcelle10}.
\end{proof}


\subsection{Proof of Theorem~\ref{thm:sync}}
\label{apx:sync}
\input{appendix/apx-sync.tex}


\subsection{Proof of Theorem~\ref{thm:co-weak-sync}}
\label{apx:thm-co-weak-sync}
\thmCoWeakSync

\etienne{Develop (for instance adding more precise references, or copy/paste), or drop this section?}

The proof is essentially identical to that given in \cite{DBLP:conf/concur/BolligGFLLS21} for the $\oneone$ case. 
We do the same reduction from the Post correspondence problem. 
The original proof considered a $\oneone$ system $\System$ with four machines (P1, P2, V1, V2), where we have 
unidirectional communication channels from provers (P1 and P2) to verifiers (V1 and V2). In particular notice 
that all the possible behaviours of $\System$ are causally ordered, i.e. $\ppL{\System} \subseteq \coMSCs$; 
according to how we built our system $\System$, it is impossible to have a pair of causally-related send 
events of P1 and P2\footnote{There is no channel between P1 and P2, and we only have unidirectional communication 
channels from provers to verifiers; it is impossible to have a causal path between two send events of P1 and P2.}, which implies that causal ordering is 
already ensured by any possible $\oneone$ behaviour of $\System$. The rest of the proof is identical to the 
$\oneone$ case.
