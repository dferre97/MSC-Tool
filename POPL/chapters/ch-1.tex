

% !TEX root = ../popl-paper.tex

In synchronous communication (also known as rendezvous communication), send and receive events are  viewed as a single entity, i.e., a receive event  happens simultaneously with its corresponding send. The  idea behind (fully) asynchronous communication, instead, is to decouple send and receive events, so that a receive event can happen indefinitely after its corresponding send. Depending on some additional constraints on those events, we can obtain new communication models that sit somewhere between synchronous and fully asynchronous communication.
In this paper we try to clarify and classify those communication models. We follow the classification introduced in \cite{DBLP:journals/fac/ChevrouHQ16} but we generalize the models to  consider unmatched messages (i.e., messages that have been sent, but not yet read). Another major difference is that in \cite{DBLP:journals/fac/ChevrouHQ16} the communication models are addressed from a linearizations standpoint, whereas we are interested in \emph{Message Sequence Charts} (MSCs in the following). 
\cinzia{def: of MSC, why MSC}
MSCs are a kind of diagram that is used to visualize computations of distributed systems. A distributed system is composed by a set of sequential processes that can exchange messages. Each process executes a local algorithm that determines a sequence of \emph{events}, which in our case will be either \emph{send} or \emph{receive} events. A send event $s$ and a receive event $r$ are said to be \emph{matching} if the message sent by $s$ is the same one that is received by $r$. A distributed computation is obtained by executing concurrently the local algorithms of the processes. In an MSC, such as the one in Fig.~\ref{fig:msc_ex}a, each vertical line is called a \emph{process line} and it represents the order in which events are executed by a single process, with time running from top to bottom; arrows are used to represent messages and they connect a send event with its matching receive event. Given a message $m_i$, we will use $!i$ and $?i$ to denote the corresponding two matching send and receive events, respectively. A single process line defines a total order over the events executed by that process, i.e. an event $e$ happens before another event $e'$ if $e$ is higher in the process line; in Fig.~\ref{fig:msc_ex}a, if we look at process $q$ we see that $?1$ happens before $?2$. However, in general MSCs only specify a partial order over events. Consider the events $!1$ and $!2$ in Fig.~\ref{fig:msc_ex}a, which are executed by two different processes; these two events are said to be \emph{concurrent}, in the sense that this MSC does not tell us which one is executed first. The fact that $!1$ is higher on his own process line compared to $!2$ does not meaning anything with respect to the order in which they are executed. Since an MSC defines a partial order over the events of a distributed system, it can always be extended to a total order, which will be referred to as a \emph{linearization}. Given an MSC, it can have multiple linearizations. For the MSC in Fig.~\ref{fig:msc_ex}a, both $!1\;?1\;!2\;?2$ and $!2\;!1\;?1\;?2$ are valid linearizations, i.e. a total order over the events which is compatible with the partial order defined by the MSC. Intuitively, a linearization represents the order in which events are executed by the distributed system according to \emph{absolute time}, i.e. as they are seen by an external viewer that has a global view of all the processes. Even though events on different processes can be concurrent, this is not always the case. Consider events $!1$ and $?2$ of the MSC shown in Fig.~\ref{fig:msc_ex}b. Even though they are executed by different processes, $?2$ must happen before $!1$ because $?2$ must be executed after $!2$, which happens before $?1$, which in turn happens before $!1$. Graphically, this happens before relation between events on different processes is represented by a path that follows the direction of the arrows and runs from top to bottom. This will be referred to as a \emph{causal path}, because it estabilished a causal relation between events. In Fig.~\ref{fig:msc_ex}b, the causal path between $!1$ and $?2$ has been highlighted with purple arrows for clarity.

\begin{figure}[h]
	\captionsetup[subfigure]{justification=centering}
	% \centering
	\begin{subfigure}[t]{0.45\textwidth}\centering
		\begin{tikzpicture}
			\newproc{0}{p}{-1.5};
			\newproc{1}{q}{-1.5};
			\newproc{2}{r}{-1.5};
		
			\newmsgm{0}{1}{-0.5}{-0.5}{1}{0.3}{black};
			\newmsgm{2}{1}{-1.0}{-1.0}{2}{0.3}{black};
				
		\end{tikzpicture}
		\caption{An example of MSC.}
	\end{subfigure}
	% \hfill
	\begin{subfigure}[t]{0.45\textwidth}\centering
		\begin{tikzpicture}
			\newproc{0}{p}{-1.5};
			\newproc{1}{q}{-1.5};
			\newproc{2}{r}{-1.5};
		
			\newmsgm{0}{1}{-0.5}{-0.5}{1}{0.3}{black};
			\newmsgm{1}{2}{-1.0}{-1.0}{2}{0.5}{black};

			\newflechehor{Purple}{-0.5}{0}{1};
			\newflechevert{Purple}{1}{-0.5}{-1.0};
			\newflechehor{Purple}{-1.0}{1}{2};
		\end{tikzpicture}
		\caption{Another example of MSC.}
	\end{subfigure}
		\caption{Two examples of MSCs.}
	    \label{fig:msc_ex}
\end{figure}

\cinzia{Have a look at \url{https://web.archive.org/web/20060826195305/http://www.comp.nus.edu.sg/~thiagu/public_papers/surveymsc.pdf}}

\cinzia{\url{https://link.springer.com/content/pdf/10.1007/978-0-387-35271-8.pdf} to mention while talking about realizability page 81-96}

Going back to our contribution, the work in \cite{DBLP:journals/fac/ChevrouHQ16} describes the properties that a single linearization must satisfy in order to be realizable by a system that uses a given communication model. On the other hand, we are interested in understanding if a given MSC describes a computation that can be realized by a system that uses some communication model $CM$. In other words, given a MSC we want to know if it has at least one linearization that respects the constraints imposed by $CM$. If that is the case, the MSC represents a behaviour that can be exhibited by a system that uses $CM$ as a communication model. These are two fundamentally dissimilar problems; at the end of this section we provide an example to clarify the difference. In our work, we are going to formally characterize the classes of MSCs which represent valid computations for all of these 7 communication models. We also show how these classes form a well-defined hierarchy, which does not correspond entirely to that found in \cite{DBLP:journals/fac/ChevrouHQ16}.


\paragraph{Contributions.}

We find of particular interest to study the relation between the classes of MSCs for all of these communication models. For instance, the MSC shown in Fig.~\ref{fig:co_ex}a is both asynchronous and FIFO $\oneone$, in the sense that we are able to find systems using those communication models that can produce the behaviour described by the MSC. Is it always the case than a FIFO $\oneone$ MSC is also an asynchronous MSC? What about the other communication models? In Section~\ref{} we prove that the classes of MSCs for all these communication models form a very neat hierarchy, which is graphically shown in Fig.~\ref{fig:msc_hierarchy_full}.

% \cinzia{redo fig in tikz}
% \begin{figure}[h]
% 	\centering
% 	\includegraphics[width=8cm]{msc_hierarchy}
% 	\caption{The hierarchy of MSC classes.}
% 	\label{fig:msc_hierarchy_full}
% \end{figure}

\begin{figure}[h]
	\centering
	\begin{tikzpicture}
		\draw  (0,0) rectangle (2,.5);
		\draw (2,0.3) node[left]{RSC};
		\draw  (0,0) rectangle (3,1);
		\draw (3,0.8) node[left]{FIFO n-n};
		\draw  (0,0) rectangle (4,1.5);
		\draw (4,1.3) node[left]{FIFO 1-n};
		\draw  (0,0) rectangle (5,2);
		\draw (5,1.8) node[left]{FIFO 1-n (mailbox)};
		\draw  (0,0) rectangle (6,2.5);
		\draw (6,2.3) node[left]{Causally ordered};
		\draw  (0,0) rectangle (7,3);
		\draw (7,2.8) node[left]{FIFO 1-1 (p2p)};
		\draw  (0,0) rectangle (8,3.5);
		\draw (8,3.3) node[left]{Asynchronous};
	\end{tikzpicture}
	\caption{The hierarchy of MSC classes.}
	\label{fig:msc_hierarchy_full}
\end{figure}

\cinzia{add fig. of results}


\paragraph{Outline.} The paper is organized as follows. Section \ref{sec:com_models_overview} details the communication models we consider. Section \ref{sec:prelim} collects formal definitions that will be used throughout the paper. Then, Section \ref{sec:MSO} gives a formal definition of MSC realizing a given communication model and characterizes the classes of MSCs via MSO logic. Finally, Sections \ref{sec:hierarchy} and \ref{sec:checking} show respectively how the different communication models are related and use this information to show some (un)decidability model checking results that follow from the notion of special treewidth.

