\documentclass[a4paper,UKenglish,cleveref, autoref, thm-restate]{lipics-v2021}

\bibliographystyle{plainurl}% the mandatory bibstyle
%
\usepackage{graphicx}
\usepackage{booktabs}
\usepackage{array}
\usepackage{verbatim}
\usepackage{sectsty}
\allsectionsfont{\sffamily\mdseries\upshape}
\usepackage{amsmath}
\usepackage{amsbsy}
\usepackage{qtree}
\usepackage[inline]{enumitem}

\usepackage{thmtools}
\declaretheorem{fact}
\usepackage{thm-restate}

\usepackage[
    linecolor=blue,
    bordercolor=blue,
    backgroundcolor=white]{todonotes}

\usepackage{float}


\usepackage{xspace}

\usepackage{amsfonts}
\usepackage{mathtools}
\usepackage{bussproofs}
\usepackage{stackengine}
\usepackage{amssymb}
\usepackage{xcolor}
\usepackage{tikz}
\usepackage{stmaryrd}
\usepackage{tikz}
\usepackage{proof}
\usetikzlibrary{automata, positioning, arrows, petri}
\usepackage[titles,subfigure]{tocloft}

\usepackage{macro}
\usepackage[normalem]{ulem}

\nolinenumbers

\def\islongversion{yes}
\def\yes{yes}
\def\no{no}



\title{A Unifying Framework for Deciding Synchronizability}


\author{Benedikt Bollig}
       {Universit{\'e} Paris-Saclay, ENS Paris-Saclay, CNRS, LMF, France}
       {bollig@lsv.ens-cachan.fr}
       {https://orcid.org/0000-0003-0985-6115}{}
\author{Cinzia Di Giusto}
       {Universit{\'e} C\^{o}te d’Azur, CNRS, I3S, France}
       {cinzia.di-giusto@univ-cotedazur.fr}
       {https://orcid.org/0000-0003-1563-6581}{}
\author{Alain Finkel}
       {Universit{\'e} Paris-Saclay, ENS Paris-Saclay, CNRS, LMF, France \and
         Institut Universitaire de France}
       {finkel@lsv.fr}
       {https://orcid.org/0000-0003-0702-3232}{}
\author{Laetitia Laversa}
       {Universit{\'e} C\^{o}te d’Azur, CNRS, I3S, France}
       {laetitia.laversa@univ-cotedazur.fr}
       {https://orcid.org/0000-0003-3775-6496}{}
\author{Etienne Lozes}
       {Universit{\'e} C\^{o}te d’Azur, CNRS, I3S, France}
       {etienne.lozes@univ-cotedazur.fr}
       {https://orcid.org/0000-0001-8505-585X}{}
\author{Amrita Suresh}
       {Universit{\'e} Paris-Saclay, ENS Paris-Saclay, CNRS, LMF, France}
       {amrita.suresh@ens-paris-saclay.fr}
       {https://orcid.org/0000-0001-6819-9093}{}

\authorrunning{B. Bollig et al.}


\Copyright{Benedikt Bollig, Cinzia Di Giusto, Alain Finkel, Laetitia Laversa, Etienne Lozes, and Amrita Suresh}

\ccsdesc[500]{Theory of computation~Formal languages and automata theory}

\keywords{MSO, MSC, bounded tree-width, communicating automata, synchronisability}


%Editor-only macros:: begin (do not touch as author)%%%%%%%%%%%%%%%%%%%%%%%%%%%\
%%%%%%%
\EventEditors{John Q. Open and Joan R. Access}
\EventNoEds{2}
\EventLongTitle{42nd Conference on Very Important Topics (CVIT 2016)}
\EventShortTitle{CVIT 2016}
\EventAcronym{CVIT}
\EventYear{2016}
\EventDate{December 24--27, 2016}
\EventLocation{Little Whinging, United Kingdom}
\EventLogo{}
\SeriesVolume{42}
\ArticleNo{23}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%




\begin{document}

\maketitle

\begin{abstract}
Several notions of synchronizability of a message-passing
system have been introduced in the literature. Roughly, a
system is called synchronizable if every execution
can be rescheduled so that it meets certain criteria, e.g.,
a channel bound. We provide a framework, based on MSO
logic and (special) tree-width, that unifies existing definitions,
explains their good properties, and allows one to easily derive other,
more general definitions and decidability results for synchronizability.

\keywords{communicating finite-state machines, message sequence charts,
synchronizability, MSO logic, special tree-width}
\end{abstract}

\section{Introduction}

\paragraph*{Communication systems.}
The model of concurrent processes communicating asynchronously through FIFO channels is used since the 1960s in many applications such as communication protocols \cite{DBLP:journals/sigops/Bochmann75}, hardware design, MPI
programs, and more recently for designing and verifying session types \cite{DBLP:journals/corr/abs-1901-09606}, web contracts, choreo\-graphies, concurrent programs, Erlang, Rust, etc.
~Since communication systems use FIFO channels, it is well known that all non-trivial properties (e.g., are all channels bounded?) are undecidable \cite{DBLP:journals/jacm/BrandZ83}, essentially because a FIFO channel may simulate the tape of Turing machines and the counters of Minsky machines.
%
However, there are many subclasses of communication systems for which the control-state reachability problem becomes decidable: for example, synchronizable systems and existentially bounded systems (every execution can be reorganised or decomposed into a finite number of sequences in which all channels are $k$-bounded), flat FIFO machines \cite{EGM2012,FP-lmcs20} (the graph of the machine does not contain nested loops), channel-recognizable systems \cite{DBLP:conf/cav/BoigelotG96}, unreliable (lossy, insertion, duplication) FIFO systems \cite{GC-AF-SPI-IC-96}, input-bounded FIFO machines \cite{BDM-concur20}, and half-duplex systems \cite{CF-icomp05}.

\paragraph*{On the boundedness problem.}
We focus on the  boundedness problem, which is known to be undecidable.  We could limit our analysis to decide whether for a given integer $k\geq 0$, known in advance, the FIFO channels are $k$-bounded, and this property is generally decidable in PSPACE. %; but we cannot know in advance the bound $k$ to test.
%	Because of this undecidability frontier and because
Unfortunately, the $k$-boundedness property is too binding since we could want to design an \emph{unbounded} system that is able, for example, to make unbounded iterations of sending  and receiving messages. Hence, to cope with this limitation, one can find
%in the literature
variants of the boundedness property that essentially reduce to say
%, for p2p systems,
that every unbounded execution of a system (i.e., channels are unbounded along the execution) is equi\-va\-lent (for instance, causally equivalent) to another \emph{bounded} execution.
%		The litterature is not unified and many similar names have been given to different properties.
%Here, we will consider the weaker $k$-synchronizable property where every $k'$-bounded behavior with $k' > k$, is the "same" than an $k$-bounded behavior.

%\alain{end of the new introduction, what follows has not been read again}

%		 let us use for now the word "Slack elasticity".

%Depending the exact definition of "Slack elasticity", $k$-synchronizability and sometimes synchronizability are decidable: for example the $k$-synchronizability in \cite{DBLP:journals/corr/abs-1804-06612,DBLP:conf/fossacs/GiustoLL20} is decidable and in fact more surprisingly, the synchronizability is also decidable \cite{DBLP:conf/fossacs/GiustoLL20}\\


%We will try to clean the vocabulary and the results and proofs

%The decidability proofs of the question "is a system $k$-synchronizable ?" and then "is reachability decidable ?" for all these models suffer frome a lack of unification.\\


%\noindent {\bf About synchronizability.}
\paragraph*{About synchronizability.}
%\alain{how to clearly and shortly present the two semantics words and MSC, the two types of communication p2p and mailbox, and the treatment of matched and unmatched messages ?}
To mention some examples, Lohrey and Mus\-choll introduced
\emph{existentially k-bounded} systems \cite{DBLP:journals/iandc/LohreyM04} (see
also \cite{DBLP:conf/fossacs/LohreyM02,DBLP:conf/dlt/GenestMK04,GKM07}) where
all accepting executions leading to a stable (with empty channels) final
configuration can be re-ordered into a $k$-bounded execution. This property is
undecidable, even for a given $k$ \cite{GKM07}. A  more general definition,
still called existentially bounded, is given in 2014 where the considered
executions are \emph{not} supposed to be final or stable
\cite{kuske2014communicating}. In  \cite{DBLP:journals/iandc/LohreyM04,HENRIKSEN20051}, the notion of
\emph{universally k-bounded} (all possible schedulings of an execution are $k$-bounded) is also
discussed and the authors show that the property is undecidable in
general.
%
%There exist many other variations of this idea in the litterature.
In 2011, Basu and Bultan introduced \emph{synchronizable} systems \cite{DBLP:conf/www/BasuB11}, for which every execution is equivalent (for the projection on sending messages)
to one of the same system but communicating by rendezvous; to avoid ambiguity, we call such systems \emph{send-synchronizable}.
%		and many papers studied it \cite{DBLP:conf/popl/BasuBO12}. undecidable in \cite{DBLP:conf/icalp/FinkelL17}
%
In 2018, Bouajjani et al., called a system $\System$ \emph{\kSable{k}} \cite{DBLP:conf/cav/BouajjaniEJQ18} (to avoid confusion %with previous and new definitions of the so-called synchronizability,
we call such systems \emph{weakly \kSable{k}}) if every MSC of $\System$
admits a linearization (which is not necessarily an execution) that can be divided into blocks of at most $k$ messages. After each block, a message is either read, or will never be read.
This constraint
%about all the MSCs of the system
seems to imply that buffers are bounded to $k$ messages.
 However,
as the linearization has not to be an execution, this implies that a weakly $k$-synchronizable execution, even with the more efficient reschedule, can need unbounded channels to be run by the system.
%\alain{we may call a system "C-bounded“  if C is robust and  L(S) is included in C}

\paragraph*{Communication architecture and variants.}
An important difference between these works is that
they consider different communication architectures.
Existentially bounded systems
have been studied for p2p communication, i.e., with one queue per
pair of processes, whereas $k$-synchronizability has been studied
for mailbox communication, for which each process merges
all its incoming messages in a unique queue. The decidability
results for $k$-synchronizability have been extended to p2p
communications~\cite{DBLP:conf/fossacs/GiustoLL20}, but
it is unknown whether the decidability results for existentially
bounded systems extend to mailbox communication. Moreover,
variants of those definitions can be
obtained if we consider messages that are sent but never read,
called unmatched messages, and various ways of taking
them into account lead to various definitions.
Indeed the challenges that arise  in  \cite{DBLP:conf/cav/BouajjaniEJQ18} are due to mailbox communication and unmatched messages blocking a channel so that all messages sent afterwards will never be read.
%This type of complication only happens in mailbox communication, as \pp one is more permissive.
To clarify and overcome this issue, we propose \emph{strong \kSity{k}}, a new definition that is suitable for mailbox communication: an execution is called \emph{strongly $k$-synchronizable} if it can be rescheduled into another $k$-bounded execution such that there are at most $k$ messages in the channels before emptying them.

%  Indeed, if each execution can be rescheduled and divided into sections of $k$ messages, we could think that buffers are bounded to $k$ messages. However,
% % 	      in \cite{DBLP:conf/cav/BouajjaniEJQ18}, the definition of weak \kSity{k},
% the reschedule of the execution has not to be an execution. It results that a weak $k$-synchronous execution, even with the more efficient reschedule, can need unbounded channels to be run by the system.
 %Another source of ambiguity is the messages that are sent but never read, called unmatched messages. Such messages block the concerned channel, and all messages sent after will never be read too.
%		They still be stored in the channel and prevent messages sent after in the same (FIFO) channel to be read.
%So in a weakly \kSable{k} system, strongly \kSable{k} system and existentially bounded system, an infinity of unmatched messages can be stored in a channel and never consummed.
% To clarify this issue, we propose a new definition, the \emph{strong \kSity{k}}:
% % (or simply \kSity{k} when there is no ambiguity)
% %in which the reschedule of an execution has to be an execution of the system.
% %\alain{say something about p2p and mailbox}
% %			Therefore, channels are not $k$-bounded.
% %
% %		We propose to count unmatched messages and
% an execution is said \emph{strongly $k$-synchronizable} if it can be rescheduled into another $k$-bounded execution
% such that \xout{there are at most $k$ unmatched messages in each channel}.
% \comL{there are at most $k$ messages in the channels before emptying them}.

% They are two classes usually called existentially bounded systems that \cite{DBLP:journals/corr/abs-1901-09606} distinguish into existentially bounded systems and existentially \emph{stable} bounded systems when the considered executions must arrive in a final stable configuration (there exists a set of final control-states) with empty channels.


%Finally, a strongly \kSable{k} system is also \existb{k} system: each execution can be reschedule to have, at each moment, at most $k$ messages in each channel.

\iffalse


%There exist variants of this definition where executions are replaced by linearization of MSC (which are not necessarly executions) and some other definitions don't consider messages that are never consummed.
\begin{center}
	\begin{tabular}{| l | l | l| }
		\hline
		& $k$-weakly-synchronizable   & $k$-existentially-bounded \\ \hline

		control-state reachability  & Decidable \cite{DBLP:journals/corr/abs-1804-06612,DBLP:conf/fossacs/GiustoLL20}  & D \cite{GKM07} \\  \hline

		repeated control-state  reachability &  \textcolor{red}{Unknown}   &  \textcolor{red}{Unknown}  \\  \hline

		configuration reachability &  \textcolor{red}{Unknown}  &  \textcolor{red}{Unknown} \\
		\hline
		boundedness &   \textcolor{red}{Unknown}  & Undecidable  \cite{GKM07}  \\
		\hline
	\end{tabular}
\end{center}

%		for later may be
\begin{center}
	\begin{tabular}{| l | l | l | l| }
		\hline
		& k-weakly-synchro  & k-strongly-synchro & existentially-bounded \\ \hline

		cs   reachability & D (2018-20) &  \textcolor{red}{D here} & D (GKM 07) \\  \hline

		repeated cs   reach &  \textcolor{red}{Unknown} &  \textcolor{red}{D}   &  \textcolor{red}{Unknown}  \\  \hline

		conf reachability &  \textcolor{red}{Unknown} &   \textcolor{red}{here } &  \textcolor{red}{Unknown} \\
		\hline
		boundedness &   \textcolor{red}{Unknown} & \textcolor{red}{Unknown } & U  (GKM 07)  \\
		\hline
	\end{tabular}
\end{center}


%%%%%%%%%%%%
\subsection{Decidability of weak and strong \kSity{k} and existentially k-bounded }\label{section:decidability_with_k}



%{\bf The three existential problems} \\

\begin{itemize}
	\item {\bf The strongly k-synchronizable problem} \\
	input : a system $S$ and $k \geq 0$ \\
	question : is S strongly k-synchronizable (SkS) ?
	\item {\bf The weakly k-synchronizable problem} \\
	input : a system $S$ and $k \geq 0$ \\
	question : is S weakly k-synchronizable (WkS) ?
	\item {\bf The existentially k-bounded problem} \\
	input : a system $S$ and $k \geq 0$ \\
	question : is S existentially k-bounded (EkB)?
\end{itemize}
%%%%%%%%%%%
\fi
%%%%%%%%%%%
%\comL{The following definitions can be applied to systems with different type of communication, such as \pp or mailbox, or compare sometimes executions of the system or MSCs, abstraction of executions preserving causal dependencies between messages.}

%\noindent {\bf Our contributions.}
\paragraph*{Contributions.}
Our contributions can be summarized as follows:
%\begin{itemize}
%\item
\begin{itemize}
\item
In order to unify the notions of synchronizability, we introduce a general
framework based on monadic second-order (MSO) logic and (special) tree-width
that captures most existing definitions of systems that may work with bounded
channels. Our framework allows us to unify and to simplify the proofs and
sometimes also to extend the statement. Moreover, reachability and model
checking are shown decidable in this framework.

\item We show that existentially %(resp. universally)
%\comEtienne{what about not talking about universally bounded in this paper (currently, we are very incomplete about it)}
bounded systems can be expressed in our framework and, as a consequence, the existentially %(resp. universally)
$k$-bounded property is decidable by using the same generic proof.

\item We generalize the existing notion of (weak) $k$-synchronizability in \cite{DBLP:conf/cav/BouajjaniEJQ18}
and we introduce three new classes of synchronizable systems, called weakly synchronizable (which are more general than weakly $k$-synchronizable), strongly synchronizable and strongly $k$-synchronizable (which are particular cases of weakly synchronizable). We then prove that these properties all fit in our framework and are all shown decidable using the same generic proof.
%
%\xout{that is always (for p2p and mailbox) a strict subclass of existentially bounded systems and for which the strong $k$-synchronizability property is}

\item We then deduce that reachability and model
checking are decidable for
six system classes (only control-state reachability was shown to be decidable for weakly $k$-synchronizable  in \cite{DBLP:conf/cav/BouajjaniEJQ18} and it is clearly also decidable for existentially/universally bounded systems but reachability properties are generally not studied for these classes of systems).

\item In order to obtain better complexity results for some classes (strongly and weakly synchronizable systems), we also use the fragment of propositional dynamic logic with loop and converse (LCPDL) instead of MSO logic in our framework.
%
%\alain{say more or less: Notice that for existentially and
%universally bounded systems, we are able to retrieve decidability as we consider
%systems without final states.}\\

%\alain{too much detailled for the introduction: Our framework allows to unify and to simplify the proofs and sometimes it also allows to extend the statement as Definition \ref{def:weak-synchr-new} of a $k$-exchange is more general than the existing Definition \ref{def:weak-synchr} but it is sufficient to obtain decidability.}
%\item

%	\item
%\alain{to modify with the new classes of weakly/strongly synchronizable}
%
%\item a general framework to capture most of the variants of synchronizability discussed above and to assess the decidability of the synchronizability problem as well as model checking (only the control-state is shown decidable in \cite{DBLP:conf/cav/BouajjaniEJQ18});


\item We provide a detailed comparison (with many examples and counterexamples) between the six synchronizable classes both for p2p and mailbox semantics (see Fig.~\ref{fig:diagram_p2p} for p2p systems and Fig.~\ref{fig:diagram_mailbox_all} for mailbox systems). In particular, we clarify the link between weakly synchronizable and existentially bounded systems for both p2p and mailbox systems, which was left open in \cite{DBLP:conf/cav/BouajjaniEJQ18} and  solved only for p2p systems in \cite[Theorem 7]{DBLP:journals/corr/abs-1901-09606} where  weakly synchronizable systems are shown to be included into existentially bounded ones when considering executions (and not MSCs as in our case).
\end{itemize}

%\noindent {\bf Outline.}
\paragraph*{Outline.}
Section 2 defines some preliminary notions such as p2p/mailbox message sequence charts (MSCs), and communicating systems. Section 3 presents the unifying MSO framework and two general theorems on $k$-synchro\-nizability and model checking. In Section 4, we apply the MSO framework to different existing definitions of synchronizability including existentially bounded systems, and we introduce a new decidable one. Section 5 studies the relations between the classes and discusses the send-synchronizability notion. In Section 6, we conclude with some final remarks.
\todo{introduction can probably be shortened}

%An Appendix with additional material and proofs is added for the reviewer convenience.






\section{Preliminaries}

%!TEX root = concur2021.tex


\subsection{Message Sequence Charts}

Assume a finite set of processes $\Procs$ and a finite set of messages $\Msg$.
The set of (\pp) channels is $\Ch = \{(p,q) \in \Procs \times \Procs \mid p \neq q\}$.
%
A send action is of the form $\sact{p}{q}{\msg}$
where $(p,q) \in \Ch$ and $\msg \in \Msg$.
It is executed by $p$ and sends message $\msg$ to $q$.
The corresponding receive action, executed by $q$, is
$\ract{p}{q}{\msg}$.
%
For $(p,q) \in \Ch$, let
$\pqsAct{p}{q} = \{\sact{p}{q}{\msg} \mid \msg \in \Msg\}$ and
$\pqrAct{p}{q} = \{\ract{p}{q}{\msg} \mid \msg \in \Msg\}$.
For $p \in \Procs$, we set
$\psAct{p} = \{\sact{p}{q}{\msg} \mid q \in \Procs \setminus \{p\}$ and $\msg \in \Msg\}$, etc.
Moreover, $\pAct{p} = \psAct{p} \cup \qrAct{p}$ will denote the set of all actions that are
executed by $p$.
Finally, $\Act = \bigcup_{p \in \Procs} \pAct{p}$
is the set of all the actions.

\paragraph*{Peer-to-peer MSCs.}
%\alain{add an example of MSC and of system and illustrate notions with it}
A \emph{\pp MSC} (or simply \emph{MSC}) over $\Procs$ and $\Msg$ is a tuple $\msc = (\Events,\procrel,\lhd,\lambda)$
where $\Events$ is a finite (possibly empty) set of \emph{events}
and $\lambda: \Events \to \Act$ is a labeling function.
For $p \in \Procs$, let $\Events_p = \{e \in \Events \mid \lambda(e) \in \pAct{p}\}$ be the set of events
that are executed by $p$.
We require that $\procrel$ is the disjoint union $\bigcup_{p \in \Procs} \procrel_p$
of relations ${\procrel_p} \subseteq \Events_p \times \Events_p$ such that
$\procrel_p$ is the direct successor relation of a total order on $\Events_p$.
For an event $e \in \Events$, a set of actions $A \subseteq \Act$, and a relation $\rel \subseteq \Events \times \Events$,
let $\sametype{e}{A}{\rel} = |\{f \in \Events \mid (f,e) \in \rel$ and $\lambda(f) \in A\}|$.
We require that ${\lhd} \subseteq \Events \times \Events$ satisfies the following:
\begin{itemize}\itemsep=0.5ex
\item[(1)] for every pair $(e,f) \in {\lhd}$, there is a send action $\sact{p}{q}{\msg} \in \Act$ such that
$\lambda(e) = \sact{p}{q}{\msg}$, $\lambda(f) = \ract{p}{q}{\msg}$, and
$\sametype{e}{\pqsAct{p}{q}}{\procrel^+} = \sametype{f}{\pqrAct{p}{q}}{\procrel^+}$,
\item[(2)] for all $f \in \Events$ such that $\lambda(f)$ is a receive action, there is $e \in \Events$ such that $e \lhd f$.
\end{itemize}
Finally, letting ${\le}_\msc = ({\procrel} \cup {\lhd})^\ast$,
we require that $\le_\msc$ is a partial order.
%We may also simply write ${\le}$ instead of $\le_{\msc}$ if
%the MSC is clear from the context.

\medskip

Condition (1) above ensures that every (p2p) channel $(p,q)$ behaves in a FIFO manner.
By Condition (2), every receive event has a matching send event.
Note that, however, there may be unmatched send events in an MSC.
We let
$\SendEv{\msc} = \{e \in \Events \mid \lambda(e)$ is a send
action$\}$,
$\RecEv{\msc} = \{e \in \Events \mid \lambda(e)$ is a receive
action$\}$,
$\Matched{\msc} = \{e \in \Events \mid$ there is $f \in \Events$
such that $e \lhd f\}$, and
$\Unm{\msc} = \{e \in \Events \mid \lambda(e)$ is a send
action and there is no $f \in \Events$ such that $e \lhd f\}$.

We do not distinguish isomorphic MSCs.
Let $\ppMSCs$ be the set of all MSCs over the given sets $\Procs$ and $\Msg$.
% For readability, and if there is no ambiguity,
% $\lambda^{-1}(\send{p}{q}{\msg})$, resp. $\lambda^{-1}(\rec{p}{q}{\msg})$,
% will be written $\ssymb(p,q,\msg)$ and, resp., $\rsymb(p,q,\msg)$ in the examples.

\bigskip

\noindent \begin{minipage}[c]{10cm}
  \begin{example}\label{ex:msc}
    For a set of processes $\procSet = \{p,q,r\}$ and a set of messages $\paylodSet = \{\msg_1, \msg_2, \msg_3, \msg_4 \}$,
    $\msc_1 = (\Events, \rightarrow, \lhd, \lambda)$
    %in Fig.~\ref{fig:msc_weak_univer}
    is an MSC where, for example,
  $e_2 \lhd e_2'$ and $e_3' \rightarrow_r e_4$.
  The dashed arrow means that the send event $\ssymb(p,q,\msg_1)$ does not have
  a matching receive.
  Moreover $e_2 \le_{\msc_1} e_3'$.
  Message $\msg_1$ is unmatched and so $e_1 \in Unm(M_1)$.
We can find a total order ${\pplin} \supseteq {\le}_{\msc_1}$
  such that $e_1 \pplin e_2' \pplin e_2' \pplin e_3
  \pplin e_3' \pplin e_4 \pplin e_4'$. We call $\pplin$ a linearization,
  which is formally defined  below.
  \end{example}
\end{minipage}
\hfill
\begin{minipage}[c]{3.5cm}

%\begin{figure}
  \begin{center}
    \begin{tikzpicture}[>=stealth,node distance=3.2cm,shorten >=1pt,
      every state/.style={text=black, scale =0.8}, semithick,
      font={\fontsize{8pt}{12}\selectfont}]
	\begin{scope}[xshift = 9cm, scale = 0.8]
		\node at (-0.3, -0.75)  (e)    {$e_1$};
		\node at (1.3, -1.5)  (e)    {$e_2$};
		\node at (-0.3, -1.5)  (e)    {$e_2'$};
		\node at (0.7, -2.25)  (e)    {$e_3$};
		\node at (2.3, -2.25)  (e)    {$e_3'$};
		\node at (2.3, -3)  (e)    {$e_4$};
		\node at (0.7, -3)  (e)    {$e_4'$};
		%MACHINES
		\draw (0,0) node{$p$} ;
		\draw (1,0) node{$q$} ;
		\draw (2,0) node{$r$} ;
		\draw (0,-0.25) -- (0,-3.5) ;
		\draw (1,-0.25) -- (1,-3.5);
		\draw (2, -0.25) -- (2, -3.5) ;
		%MESSAGES
		\draw[>=latex,->, dashed] (0,-0.75) -- (1, -0.75) node[midway,above]{$\amessage_1$};

		\draw[>=latex,->] (1, -1.5) -- (0, -1.5) node[midway, above] {$\amessage_2$};

		\draw[>=latex,->] (1,-2.25) -- (2,-2.25) node[midway, above] {$\amessage_3$};

		\draw[>=latex,->] (2,-3) -- (1,-3) node[midway,above] {$\amessage_4$};
	\end{scope}

\end{tikzpicture}
\captionof{figure}{MSC $\msc_1$}
\label{fig:msc_weak_univer}

\end{center}
%\alain{NIce}
%\end{figure}

\end{minipage}


\paragraph*{Mailbox MSCs.}

For an MSC $\msc = (\Events,\procrel,\lhd,\lambda)$, we define
an additional binary relation that represents a constraint
under the mailbox semantics where each process has only one incoming channel.
Let ${\mbrel}_\msc \subseteq \Events \times \Events$
be defined by: $e_1 \mbrel_\msc e_2$ if there is $q \in \Procs$
such that $\lambda(e_1) \in \qsAct{q}$,
$\lambda(e_2) \in \qsAct{q}$, and one of the following holds:
\begin{itemize}\itemsep=0.5ex
\item $e_1 \in \Matched{\msc}$ and $e_2 \in \Unm{\msc}$, or
\item $e_1 \lhd f_1$ and $e_2 \lhd f_2$ for some $f_1,f_2 \in \Events_q$ such that $f_1 \procrel^+ f_2$.
\end{itemize}

We let ${\preceq_\msc} = ({\procrel} \,\cup\, {\lhd} \,\cup\, {\mbrel_\msc})^\ast$.
Note that ${\le_\msc} \subseteq {\preceq_\msc}$.
%
%\begin{definition}\label{def:mailbox-msc}
We call $\msc \in \ppMSCs$ a \emph{mailbox MSC}
if ${\preceq_\msc}$ is a partial order.
%\end{definition}
Intuitively, this means that events can be scheduled in a way that corresponds
to the mailbox semantics, i.e., with one incoming channel per process.
Following the terminology in \cite{DBLP:conf/cav/BouajjaniEJQ18}, we also say that
a mailbox MSC satisfies \emph{causal delivery}.
The set of mailbox MSCs $\msc \in \ppMSCs$ is denoted by $\cdMSCs$.

\begin{example}\label{ex:mailbox-msc}
  MSC $\msc_1$ is a mailbox MSC. Indeed, even though the order $\linrel$ defined in Example~\ref{ex:msc} does not respect all mailbox constraints, particulary the fact that $e_4 \mbrel_{\msc_1} e_1$, there is a total order $ {\mblin} \supseteq {\preceq_{\msc_1}}$ such that $
  e_2 \mblin e_3 \mblin e_3' \mblin e_4' \mblin e_1 \mblin e_2' \mblin e_4'$. We call $\mblin$ a mailbox linearization.
\end{example}

\paragraph*{Linearizations, Prefixes, and Concatenation.}

Consider $\msc = (\Events,\procrel,\lhd,\lambda) \in \MSCs$.
A \emph{\pp linearization} (or simply \emph{linearization}) of $\msc$ is a (reflexive) total order
${\linrel} \subseteq \Events \times \Events$ such that ${\le_\msc} \subseteq
{\linrel}$. Similarly,
a \emph{mailbox linearization} of $\msc$ is a total order
${\linrel} \subseteq \Events \times \Events$ such that ${\preceq_\msc} \subseteq
{\linrel}$. That is, every mailbox linearization is a \pp linearization,
but the converse is not necessarily true (Example~\ref{ex:mailbox-msc}).
Note that an MSC is a mailbox MSC iff it has at least one mailbox linearization.
\todo{talk about linearizations in conference version?}

\medskip

Let $\msc = (\Events,\procrel,\lhd,\lambda) \in \MSCs$ and consider
$E \subseteq \Events$ such that $E$ is ${\le_\msc}$-\emph{downward-closed}, i.e,
for all $(e,f) \in {\le_\msc}$ such that $f \in E$, we also have $e \in E$.
Then, the MSC $(E,{\procrel} \cap (E \times E),{\lhd} \cap (E \times E),\lambda')$,
where $\lambda'$ is the restriction of $\Events$ to $E$, is called a \emph{prefix}
of $\msc$. In particular, the empty MSC is a prefix of $\msc$.
We denote the set of prefixes of $\msc$ by $\Pref{\msc}$.
This is extended to sets $L \subseteq \MSCs$ as expected, letting
$\Pref{L} = \bigcup_{\msc \in L} \Pref{\msc}$.

\begin{restatable}{lemma}{prefixmailbox}
\label{lem:mb-prefix}
Every prefix of a mailbox MSC is a mailbox MSC.
\end{restatable}

Let $\msc_1 = (\Events_1,\procrel_1,\lhd_1,\lambda_1)$ and
$\msc_2 = (\Events_2,\procrel_2,\lhd_2,\lambda_2)$ be two MSCs.
Their \emph{concatenation} $\msc_1 \cdot \msc_2 = (\Events,\procrel,\lhd,\lambda)$ is defined if, for all $(p,q) \in \Ch$,
$e_1 \in \Unm{\msc_1}$, and
$e_2 \in \Events_2$ such that $\lambda(e_1) \in \pqsAct{p}{q}$
and $\lambda(e_2) \in \pqsAct{p}{q}$,
we have $e_2 \in \Unm{\msc_2}$.
As expected, $\Events$ is the disjoint union of $\Events_1$ and $\Events_2$,
${\lhd}  = {\lhd_1} \cup {\lhd_2}$, $\lambda$ is the ``union'' of $\lambda_1$
and $\lambda_2$, and ${\procrel} = {\procrel_1} \cup {\procrel_2} \cup R$.
Here, $R$ contains, for all $p \in \Procs$ such that $(\Events_1)_p$ and
$(\Events_2)_p$ are nonempty, the pair $(e_1,e_2)$ where $e_1$ is the
maximal $p$-event in $M_1$ and $e_2$ is the minimal $p$-event in $M_2$.
Note that $\msc_1 \cdot \msc_2$ is indeed an MSC and that
concatenation is associative.


\subsection{Communicating Systems}

We now recall the definition of communicating systems (aka communicating finite-state
machines or message-passing automata), which consist of finite-state machines $A_p$
(one for every process $p \in \Procs$) that can communicate through the FIFO channels
from $\Ch$.

\begin{definition}\label{def:cs}
A \emph{communicating system} over $\Procs$ and $\Msg$ is a tuple
   $ \Sys = (A_p)_{p\in\procSet}$. For each
  process $p$, $A_p = (Loc_p, \delta_p, \ell^0_p)$ is a finite transition system where
  $\Loc_p$ is a finite set of local (control) states, $\delta_p
  \subseteq \Loc_p \times \pAct{p} \times \Loc_p$ is the
  transition relation, and $\ell^0_p$ is the initial state.
\end{definition}

Given $p \in \Procs$ and a transition $t = (\ell,a,\ell') \in \delta_p$, we let
$\tsource(t) = \ell$, $\ttarget(t) = \ell'$, $\tlabel(t) = a$, and
$\tmessage(t) = \msg$ if $a \in \msAct{\msg} \cup \mrAct{\msg}$.

\smallskip

There are in general two ways to define the semantics of a communicating system.
Most often it is defined as a global infinite transition system that keeps track
of the various local control states and all (unbounded) channel contents.
As, in this paper, our arguments are based on a graph view of MSCs, we will define
the language of $\Sys$ directly as a set of MSCs. These two semantic views are essentially
equivalent, but they have different advantages depending on the context.
We refer to \cite{CyriacG14} for a thorough discussion.

Let $\msc = (\Events,\procrel,\lhd,\lambda)$ be an MSC.
A \emph{run} of $\Sys$ on $\msc$ is a mapping
$\rho: \Events \to \bigcup_{p \in \Procs} \delta_p$
that assigns to every event $e$ the transition $\rho(e)$
that is executed at $e$. Thus, we require that
\begin{itemize}
\item for all $e \in \Events$, we have $\tlabel(\rho(e)) = \lambda(e)$,
\item for all $(e,f) \in {\procrel}$, $\ttarget(\rho(e)) = \tsource(\rho(f))$,
\item for all $(e,f) \in {\lhd}$, $\tmessage(\rho(e)) = \tmessage(\rho(f))$,
and
\item for all $p \in \Procs$ and $e \in \Events_p$ such that there is no $f \in \Events$ with $f \procrel e$, we have $\tsource(\rho(e)) = \ell_p^0$.
\end{itemize}

Letting run $\Sys$ directly on MSCs is actually very convenient.
This allows us to associate with $\Sys$ its p2p language and mailbox language
in one go. The \emph{\pp language} of $\Sys$ is $\ppL{\Sys} = \{\msc \in \ppMSCs \mid$ there is a run of $\Sys$ on $\msc\}$.
The \emph{mailbox language} of $\Sys$ is $\mbL{\Sys} = \{\msc \in \mbMSCs \mid$ there is a run of $\Sys$ on $\msc\}$.

Note that, following \cite{DBLP:conf/cav/BouajjaniEJQ18,DBLP:conf/fossacs/GiustoLL20},
we do not consider final states or final configuration, as our purpose is to
reason about all possible
traces that can be \emph{generated} by $\Sys$. We will discuss this issue
in more detail later in the paper.
The next lemma is obvious for the p2p semantics and follows from Lemma~\ref{lem:mb-prefix} for
	the mailbox semantics.

\begin{restatable}{lemma}{prefixclosed}
For all $\comsymb \in \{\ppsymb, \mbsymb\}$, $\cL{\Sys}$ is prefix-closed:
$\Pref{\cL{\Sys}} \subseteq \cL{\Sys}$.
\end{restatable}

\begin{example}
Fig.~\ref{fig:system_weak_univer} depcicts $\System_1 = (A_p, A_q, A_r)$ such that MSC $\msc_1$ in Fig.~\ref{fig:msc_weak_univer} belongs to $\ppL{\System_1}$ and to $\mbL{\System_1}$.
There is a unique run $\rho$ of $\System_1$ on $M_1$.
We can see that $(e_3',e_4) \in {\rightarrow_r}$ and $\ttarget(\rho(e_3')) = \tsource(\rho(e_4)) = \ell_r^{1}$, $(e_2, e_2') \in \lhd_{\msc_1}$, and $\tmessage(\rho(e_2)) = \tmessage(\rho(e_2')) = \msg_2$.
\end{example}
\begin{figure}[t]
\begin{center}
  \begin{tikzpicture}[>=stealth,node distance=3.2cm,shorten >=1pt,
    every state/.style={text=black, scale =0.75}, semithick,
    font={\fontsize{8pt}{12}\selectfont},
    scale = 0.9
    ]
  \begin{scope}[->]
      \node[state,initial,initial text={}] (q0)  {$\ell_p^{0}$};
      \node[state, right of=q0] (q1)  {$\ell_p^{1}$};
			\node[state, right of=q1] (q2) {$\ell_p^{2}$};

    	\path (q0) edge node [above] {$\send{p}{q}{\msg_1}$} (q1);
			\path (q1) edge node [above] {$\rec{q}{p}{\msg_2}$}(q2);
    	\node[thick] at (-1.1,0) {$A_p$};
  \end{scope}

  \begin{scope}[->, shift={(7.5,0)}]
      \node[state,initial,initial text={}] (q0)  {$\ell_q^{0}$};
			\node[state, right of=q0] (q1)  {$\ell_q^{1}$};
			\node[state, below of=q1, node distance = 1.75cm] (q2) {$\ell_q^{2}$};
			\node[state, left of=q2] (q3)  {$\ell_q^{3}$};

			\path (q0) edge node [above] {$\send{q}{p}{\msg_2}$} (q1);
			\path (q1) edge node [right] {$\send{q}{r}{\msg_3}$}(q2);
			\path (q2) edge node [above] {$\rec{r}{q}{\msg_4}$} (q3);
			\node[thick] at (-1.1,0) {$A_q$};
  \end{scope}

	\begin{scope}[->, shift={(0,-1.5)} ]
      \node[state,initial,initial text={}] (q0)  {$\ell_r^{0}$};
			\node[state, right of=q0] (q1)  {$\ell_r^{1}$};
			\node[state, right of=q1] (q2) {$\ell_r^{2}$};

			\path (q0) edge node [above] {$\rec{q}{r}{\msg_3}$} (q1);
			\path (q1) edge node [above] {$\send{r}{q}{\msg_4}$}(q2);
			\node[thick] at (-1.1,0) {$A_r$};
  \end{scope}
\end{tikzpicture}
\captionof{figure}{System $\System_1$}
\label{fig:system_weak_univer}
\end{center}
\end{figure}


\subsection{Conflict Graph}

We now recall the notion of a conflict graph associated to an MSC defined in \cite{DBLP:conf/cav/BouajjaniEJQ18}. This graph is used to depict the causal dependencies between message exchanges.  Intuitively, we have a dependency whenever
two messages have a process in common. For instance, an $\xrightarrow{SS}$
dependency between message exchanges $v$ and $v'$ expresses the fact that
$v'$ has been sent after $v$, by the same process. This notion is of interest because it was seen in \cite{DBLP:conf/cav/BouajjaniEJQ18} that the notion of synchronizability in MSCs (which is studied in this paper) can be graphically characterized by the nature of the associated conflict graph.

Every MSC has a unique
conflict graph associated to it. It is defined in terms of linearizations
in \cite{DBLP:conf/fossacs/GiustoLL20}, but we equivalently express it
directly in terms of MSCs.

\newcommand{\type}{t}
\newcommand{\stype}{S}
\newcommand{\rtype}{R}
\newcommand{\mexch}{\mu}
\newcommand{\Edges}{\mathit{Edges}}

For an MSC $\msc = (\Events, \rightarrow, \lhd, \lambda)$ and
$e \in \Events$, we define the type $\type(e) \in \{\stype,\rtype\}$ of $e$ by $\type(e) = \stype$ if $e \in \SendEv{\msc}$
and $\type(e) = \rtype$ if $e \in \RecEv{\msc}$.
Moreover, for $e \in \Unm{\msc}$, we let $\mexch(e) = e$,
and for $(e,e') \in \lhd$, we let $\mexch(e) = \mexch(e') = (e,e')$.


\begin{definition}[Conflict graph]
	The \emph{conflict graph} $\cgraph{\msc}$ of an MSC $\msc = (\Events, \rightarrow, \lhd, \lambda)$ is the labeled graph $(V, \Edges)$, with $\Edges \subseteq \Events \times \{\stype,\rtype\}^2 \times \Events$, defined by
	$V = {\lhd} \cup \Unm{\msc}$ and $\Edges = \{(e,\type(e)\type(f),f) \mid (e,f) \in {\to^+}\}$.
\end{definition}


\section{Model Checking and Synchronizability}

In this section, we survey two classical decision problems
for communicating systems.
The first problem is the model-checking problem, in which
one checks whether a given system satisfies a given
specification. A canonical specification language for MSCs is
monadic second-order (MSO) logic.
However, model checking in full generality is undecidable.
A common approach is, therefore, to restrict the behavior of
the given system to MSCs of bounded (special) tree width.
%
Next, we introduce MSO logic and special tree width.

\subsection{Logic and Special Tree-Width}

\paragraph*{Monadic second-order logic.}
The set of MSO formulas over MSCs is given by the grammar
$
\phi ::= x \procrel y \mid x \lhd y \mid \lambda(x) = a \mid x = y \mid x \in X \mid \exists x.\phi \mid \exists X.\phi \mid \phi \vee \phi \mid \neg \phi
$,
where $a \in \Act$, $x$ and $y$ are first-order variables, interpreted as
events of an MSC, and $X$ is a second-order variable, interpreted
as a set of events. We assume that we have an infinite supply of variables.
The satisfaction relation is defined in the standard way and self-explanatory.
For example, the formula $\neg\exists x.(\bigvee_{a \in \sAct} \lambda(x) = a \;\wedge\; \neg \mathit{matched}(x))$
with $\mathit{matched}(x) = \exists y.x \lhd y$
says that there are no unmatched send events.
It is not satisfied by the MSCs $M_1$ and $M_2$
from Figs.~\ref{fig:msc_weak_univer} and \ref{fig:msc_weak_exist},
as message $\msg_1$ is not received,
but by $M_4$ from Fig.~\ref{fig:msc_strong_exist}.

Given a sentence $\phi$, i.e., a formula without free variables,
we let $L(\phi)$ denote the set of (p2p) MSCs that satisfy $\phi$.

It is worth mentioning that the (reflexive) transitive closure of
a binary relation defined by an MSO formula with free variables $x$ and $y$,
such as $x \procrel y$, is MSO-definable so that the logic can freely
use formulas of the form $x \procrel^+ y$ or $x \le y$ (where $\le$
is interpreted as $\le_\msc$ for the given MSC $\msc$).
Therefore, the definition of a mailbox MSC can be readily translated into
the formula $\mbformula = \neg \exists x.\exists y.(\neg (x = y) \wedge x \preceq y \wedge y \preceq x)$ so that we have $L(\mbformula) = \mbMSCs$.
Here, $x \preceq y$ is obtained as the MSO-definable reflexive transitive closure of
the union of the MSO-definable relations $\procrel$, $\lhd$, and $\sqsubset$.
In particular, we define
\[
x \sqsubset y =
\displaystyle
\hspace{-1em}\bigvee_{\substack{q \in \Procs\\a,b \in \qsAct{q}}}\hspace{-1em}
\lambda(x) = a \;\wedge\; \lambda(y) = b
\wedge
\left(
\begin{array}{rl}
& \mathit{matched}(x) \wedge \neg \mathit{matched}(y)\\[1ex]
\vee & \exists x'.\exists y'. (x \lhd x' \;\wedge\; y \lhd y' \;\wedge\; x' \procrel^+ y')
\end{array}
\right).
\]


\paragraph*{Propositional Dynamic Logic (with Loop and Converse).}

For better complexity, we introduce PDL with Loop and Converse, called LCPDL henceforth.
Its syntax is:
\begin{align*}
	&\Phi ::=  \Exists \sigma \mid \Phi \vee \Phi \mid \neg \Phi &\text{(sentence)} \\
	&\sigma ::= a \mid \sigma \vee \sigma \mid \neg \sigma \mid \langle \pi \rangle \sigma \mid \Loop{\pi} &\text{(event formula)} \\
	&\pi ::= {\to} \mid {\lhd} \mid \test{\sigma} \mid \jump \mid \pi + \pi \mid \pi \cdot \pi \mid \pi^* \mid \inv{\pi} &\text{(path formula)}
\end{align*}
where $a \in \Sigma$. A sentence $\Phi$ is evaluated wrt. an MSC $\msc$. An event formula $\sigma$ is
evaluated wrt. $\msc$ and an event $e \in \Events$. Finally, a path formula $\pi$ is evaluated over two events. It defines a binary relation $\llbracket \pi \rrbracket _\msc \subseteq \Events \times \Events$.
We describe the semantics for the logic in Figure~\ref{fig:sem-lcpdl}. We use the top symbol ($\top $) to denote a tautology event formula (such as $a \wedge \neg a$), with the dual symbol $\bot = \neg \top$.
Moreover, we let $L(\Phi) = \{\msc \in \MSCs \mid \msc \models \Phi\}$.
\begin{figure}[t]
\centering
\def\arraystretch{1.2}
$\begin{array}{ll}
\makebox[5.5em][l]{$M \models \Exists \sigma$}  \text{~ if ~} \llbracket \sigma \rrbracket_\msc \neq \emptyset &
\llbracket \to \rrbracket_\msc := {\to} \text{~~ and ~~} \llbracket \lhd \rrbracket_\msc := {\lhd}\\
\makebox[5.5em][l]{$\msc, e \models a$} \text{~ if  ~} \lambda(e) = a &
\makebox[5em][l]{$\llbracket \test{\sigma} \rrbracket_\msc$} := \{ (e,e) \mid e \in \llbracket \sigma \rrbracket _\msc\}
\\
\makebox[5.5em][l]{$\msc, e \models \langle \pi \rangle \phi$} \text{~ if  ~} \exists f \in \llbracket \pi \rrbracket _\msc (e) : M, f \models \phi~~~~~ &
\makebox[5em][l]{$\llbracket \jump \rrbracket_\msc$} := \Events \times \Events\\
\msc, e \models \Loop{\pi} \text{~ if ~} (e, e) \in \llbracket \pi \rrbracket_\msc &
\makebox[5em][l]{$\llbracket \pi_1 + \pi_2 \rrbracket_\msc$} := \llbracket \pi_1\rrbracket_\msc \cup \llbracket \pi_2 \rrbracket_\msc \\
\multicolumn{1}{l}{\llbracket \inv{\pi} \rrbracket_\msc := \{ (f, e) \in \Events \times \Events \mid (e,f) \in \llbracket \pi \rrbracket_\msc\}} &
\makebox[5em][l]{$\llbracket \pi^* \rrbracket_\msc$} := \bigcup_{n \in \mathbb{N}}\llbracket \pi \rrbracket_\msc^n\\
\multicolumn{2}{l}{\llbracket \pi_1 \cdot \pi_2 \rrbracket_\msc := \{(e,f) \in \Events \times \Events \mid \exists g \in \Events : (e,g) \in \llbracket \pi_1 \rrbracket_\msc \text{~and~} (g, f) \in \llbracket \pi_2 \rrbracket_\msc  }
\end{array}$
\caption{Semantics of LCPDL\label{fig:sem-lcpdl}}
\end{figure}

It can be seen below that mailbox semantics can be readily translated into the LCPDL formula
$\mbFormula = \neg \Loop{({\lhd} + {\procrel} + {\sqsubset})^+}$
such that $L(\mbFormula) = \mbMSCs$. Hereby, we let
\[{\sqsubset} = {\lhd} \cdot {\procrel^+} \cdot {\inv{\lhd}} ~~+ \sum_{\substack{q \in \Procs\\a,b \in \qsAct{q}}} \test{a} \cdot {\lhd} \cdot \jump \cdot \test{b \wedge \neg \langle \lhd \rangle \top}\,.\]

\paragraph*{Special Tree-Width.}


\emph{Special tree-width} \cite{Courcelle10},
is a graph measure that indicates how close
a graph is to a tree (ne may also use classical
	\emph{tree-width} instead).
This or similar measures are commonly employed in verification. For instance, tree-width and split-width have been used in \cite{} and, respectively, \cite{DBLP:conf/concur/CyriacGK12} to reason about graph behaviors generated by pushdown systems. Here we wish to apply it to reason about MSCs.
There are several ways to define the special tree-width of an MSC.
We adopt the following game based definition from \cite{DBLP:journals/corr/abs-1904-06942}.

Adam and Eve play a two-player turn based ``decomposition game''
whose positions
are MSCs with some pebbles placed on some events.
More precisely, Eve's positions are
\emph{marked MSC fragments} $(M, U)$, where
$\msc = (\Events, \procrel, \lhd, \lambda)$
is an \emph{MSC fragment} (an MSC with possibly some edges from
$\lhd$ or $\to$ removed)
 and $U \subseteq \Events$ is the subset of marked events.
Adam's positions are pairs of marked MSC fragments.
A move by Eve consists in the following steps:
\begin{enumerate}
	\item marking some events of the MSC resulting in $(M, U')$ with $U \subseteq U' \subseteq \Events$,
	\item removing (process and/or message) edges whose endpoints are marked,
	\item dividing $(M, U)$ in $(M_1, U_1)$ and $(M_2, U_2)$ such that $M$ is the disjoint (unconnected) union of $M_1$ and $M_2$
	and marked nodes are inherited.
\end{enumerate}
When it is Adam's turn, he simply chooses one of the two marked MSC fragments.
The initial position is $(\msc,\emptyset)$, and a terminal position is a position $(M, U)$ belonging to Eve such that events are marked, i.e., $U = \Events$.

We say that the game is $k$-winning for Eve if she has a (positional) strategy that allows her to reach a terminal position such that, in every single position visited along the play (including the final one),
there are at most $k+1$ marked events.


\begin{fact}[\cite{DBLP:journals/corr/abs-1904-06942}]
	The special tree-width of an MSC is the least $k$ such that
	the associated game is $k$-winning for Eve.
\end{fact}



\subsection{Model Checking}

In general, even simple verification problems, such
as control-state reachability, are undecidable for
communicating systems \cite{DBLP:journals/jacm/BrandZ83}.
However, they are decidable when we restrict to behaviors of
bounded special tree-width, which motivates the following
definition of a generic {\bf bounded model-checking problem} for $\comsymb \in \{\ppsymb, \mbsymb\}$:\\
{\bf Input:} Two finite sets $\Procs$ and $\Msg$, a communicating system $\System$, an MSO sentence $\phi$, and $k \in \N$.\\
{\bf Question:} Do we have $\cL{\Sys} \cap \stwMSCs{k} \subseteq L(\phi)$?


\newcommand{\CS}[2]{\mathsf{CS}_{(#1,#2)}}
\newcommand{\MSO}[2]{\mathsf{MSO}_{(#1,#2)}}
\newcommand{\LCPDL}[2]{\mathsf{LCPDL}_{(#1,#2)}}
\newcommand{\MSCpm}[2]{\mathsf{MSC}_{(#1,#2)}}
\newcommand{\mbMSCpm}[2]{\mathsf{MSC}_{(#1,#2)}^{\mathsf{mb}}}


\begin{fact}[\cite{DBLP:journals/corr/abs-1904-06942}]\label{p2p}
The bounded model-checking problem for $\comsymb = \ppsymb$ is decidable.
When the formulas $\phi$ are from LCPDL, then the problem is solvable
in exponential time.
\end{fact}

Using $\mbformula$ or $\mbFormula$, we obtain the corresponding result
for mailbox systems as a corollary (cf.\ Appendix~\ref{app:mailbox} for the proof):

\begin{restatable}{theorem}{boundedmc}
\label{mailbox}
The bounded model-checking problem for $\comsymb =  \mbsymb$ is decidable.
When the formulas $\phi$ are from LCPDL, then the problem is solvable
in exponential time.
\end{restatable}



\subsection{Synchronizability}

The above model-checking approach is incomplete in the sense that
a positive answer does not imply correctness of the whole
system. The system may still produce behaviors of special tree-width greater than $k$
that violate the given property.
However, if we know that a system only generates
behaviors from a class whose special tree-wdith is bounded by $k$,
we can still conclude that the system is correct.

This motivates the \emph{synchronizability problem}.
Several notions of synchronizability have been introduced in the literature.
However, they all amount to asking whether all behaviors generated by
a given communicating system have a particular shape,
i.e., whether they are all included in a fixed (or given) set of MSCs $\Class$.
Thus, the synchronizability problem is essentially an inclusion problem,
namely $\ppL{\Sys} \subseteq \Class$ or $\mbL{\Sys} \subseteq \Class$.
%
We show that, for decidability, it is enough to have that $\Class$
is MSO-definable and special-tree-width-bounded (STW-bounded):
%
We call $\Class \subseteq \MSCs$
\begin{enumerate*}[label={(\roman*)}]
\item \emph{MSO-definable} if there is
an MSO-formula $\phi$ such that $L(\phi) = \Class$,
\item \emph{LCPDL-definable} if there is an
an LCPDL-formula $\Phi$ such that $L(\Phi) = \Class$,
\item \emph{STW-bounded} if there is $k \in \N$
such that $\Class \subseteq \stwMSCs{k}$,
\item \emph{\nameclass} if it is MSO-definable and STW-bounded.
\end{enumerate*}

An important ingredient of the decidability proof is the following lemma,
which shows that we can reduce synchronizability
to bounded model-checking, provided the given class
is STW-bounded.

\begin{restatable}{lemma}{lemcontinuous}\label{lem:continuous}
For $k \in \N$ and $\Class \subseteq \stwMSCs{k}$,
$\cL{\System} \subseteq \Class$ iff
$\cL{\System} \cap \stwMSCs{(k+2)} \subseteq \Class$.
\end{restatable}

The result follows from the following lemma, whose proof is in
Appendix~\ref{app:continuous2}:

\begin{restatable}{lemma}{lemcontinuoustwo}\label{lem:continuous2}
	Let $k \in \N$ and $\Class \subseteq \stwMSCs{k}$. For all
	$M \in \MSCs \setminus \Class$, we have
	$(\Pref{M} \cap \stwMSCs{(k+2)}) \setminus \Class \neq \emptyset$.
\end{restatable}


We now have all ingredients to state a generic decidability result
for synchronizability:

\begin{theorem}\label{thm:sync}
Fix finite sets $\Procs$ and $\Msg$.
Suppose $\comsymb \in \{\ppsymb, \mbsymb\}$ and let $\Class \subseteq \MSCs$ be a robust class (over $\Procs$ and $\Msg$).
The following problem is decidable:
Given a communicating system $\System$, do we have $\cL{\System} \subseteq \Class$?
\end{theorem}

\begin{proof}
Consider the MSO-formula $\phi$ such that $L(\phi) = \Class$, and
let $k \in \N$ such that $\Class \subseteq \stwMSCs{k}$.
We have
$\cL{\System} \subseteq \Class
 \stackrel{\textup{Lemma~\ref{lem:continuous}}}{\Longleftrightarrow} \cL{\System} \cap \stwMSCs{(k+2)} \subseteq \Class
 \Longleftrightarrow \cL{\System} \cap \stwMSCs{(k+2)} \subseteq L(\phi)$.
The latter can be solved thanks to Fact~\ref{p2p} and Theorem~\ref{mailbox}.
\end{proof}

\begin{remark}
Note that, in some cases, the concrete class $\Class$ is parameterized by a natural number and
part of the input. In that case, we need to be able to compute the
MSO formula characterizing it as well as the bound in the special tree-width $k$.
This is also important for complexity-theoretic characterizations.
\end{remark}





\section{Application to Concrete Classes of Synchronizability}

In this section, we instantiate our general framework by specific classes.


\subsection{A New General Class: Weakly Synchronous MSCs} \label{sec:weakly-sync}

We first introduce the class of weakly synchronous MSCs. This is a generalization of synchronous MSCs studied earlier, in \cite{DBLP:conf/cav/BouajjaniEJQ18, DBLP:conf/fossacs/GiustoLL20}, which we shall discuss in the later sections. Intuitively, we say an MSC is weakly synchronous if there exists a linearisation that is breakable into a sequence of exchanges, such that a message sent during an exchange cannot be received during a subsequent one: either it is received during the same exchange, or it remains orphan forever. We define these notions formally below.

\begin{definition}[exchange]\label{def:weak-synchr}
Let $\msc = (\Events,\procrel,\lhd,\lambda)$ be an MSC.
We say that $\msc$ is an \emph{exchange} if
$\SendEv{\msc}$ is
a ${\le_\msc}$-downward-closed set.
\end{definition}




\begin{definition}[weakly synchronous]\label{def:weaksync-new}
We say that $\msc \in \MSCs$ is
\emph{weakly synchronous} if it is of the form
$\msc = \msc_1 \cdot \ldots \cdot \msc_n$
such that every $\msc_i$ is an exchange.
\end{definition}


\noindent
\begin{minipage}[c]{10.5cm}
We use the term \emph{weakly} to distinguish
it from variants that we introduce later.

\begin{example}\label{example:msc_W}
	Consider the MSC $\msc_2$ in Fig.~\ref{fig:msc_W}. It is is weakly-synchronous. Indeed, $\amessage_1$, $\amessage_2$, and $\amessage_5$ are independent and can be put alone in an exchange. Repetitions of $\amessage_3$ and $\amessage_4$ are interlaced, but they constitute an exchange, as we can do all sends and then all receptions.
\end{example}
\end{minipage}
\begin{minipage}[c]{3cm}
	\hspace*{1cm}
\begin{center}
  \begin{tikzpicture}[>=stealth,node distance=3.4cm,shorten >=1pt,
  every state/.style={text=black, scale =0.7}, semithick,
    font={\fontsize{8pt}{12}\selectfont}]

\begin{scope}[shift = {(8,0.75)}, scale = 0.8]
  %MACHINES
  \draw (0,1.25) node{$q$} ;
  \draw (1.5,1.25) node{$r$} ;
  \draw (-1.25,1.25) node{$p$} ;
  \draw (0,1) -- (0,-3.5) ;
  \draw (1.5,1) -- (1.5,-3.5);
  \draw (-1.25,1) -- (-1.25,-3.5);

  %MESSAGES
  \draw[>=latex,->, dashed] (-1.25, 0.5) -- (0, 0.5) node[ above, midway] {$\amessage_1$};
  \draw[>=latex,->] (0, 0) -- (-1.25, 0) node[ above, midway] {$\amessage_2$};


  \draw[>=latex,->] (0, -0.5) -- (1.5, -1.85) node[pos=0.1, sloped, above] {$\amessage_3$};
  \draw[>=latex,->] (0, -1.25) -- (1.5, -2.6) node[pos=0.7, sloped, above] {$\amessage_3$}; %{$\amessage_1'$};
  %\draw[>=latex,->, dashed] (0, -2.5) -- (1.25, -3.25) node[pos=0.55, sloped, above] {$\amessage_1''$};

  \draw[>=latex,->] (1.5, -0.5) -- (0, -1.85) node[pos=0.1, sloped, above] {$\amessage_4$};
  \draw[>=latex,->] (1.5, -1.25) -- (0, -2.6) node[pos=0.7, sloped, above] {$\amessage_4$}; %{$\amessage_2'$};
  %\node[rotate = 90, left]at (1.13, -0.65) {$\cdots$};
  %\node[rotate = -90, right]at (0.1, -0.65) {$\cdots$};

  \draw[>=latex,->] (1.5, -3) -- (0, -3) node[ above, midway] {$\amessage_5$};


\end{scope}

\end{tikzpicture}
\captionof{figure}{MSC $\msc_{2}$}
\label{fig:msc_W}
\end{center}
\end{minipage}


An easy adaptation of a characterization from \cite{} yields:

\begin{restatable}{proposition}{newweaklogiccg}
\label{prop:newweaklogiccg}
An MSC $\msc \in \MSCs$ is  weakly synchronous iff no RS edge occurs on any cyclic path in the conflict graph.
\end{restatable}


It is easily seen that the characterization from
Proposition~\ref{thm:weakly-sync} is LCPDL-definable.

\begin{restatable}{corollary}{weaksynclcpdl}
\label{cor:weak-sync-lcpdl}
The sets of weakly synchronous MSCs and weakly synchronous \emph{mailbox} MSCs are LCPDL-definable.
Both formulas have linear size.
\end{restatable}

Moreover, under the mailbox semantics, we can show:

\begin{restatable}{proposition}{newweaklogicstw}
	\label{prop:new-weak-logic-bounded}
The set of weakly synchronous mailbox MSCs is
STW-bounded (in fact, it is included in $\stwMSCs{4|\Procs|}$).
\end{restatable}


\begin{proof}
Let $\msc$ be fixed, and let us sketch Eve's winning strategy.

The first step for Eve is to split $\msc$ in exchanges. She first disconnects
the first exchange from the rest of the graph ($2n$ pebbles are needed),
then she disconnects the second exchange from the rest of the graph ($2n$ pebbles needed, plus $n$ pebbles remaining from the first round), and so on for
each exchange.

So we are left with designing a winning strategy for Eve with $4n+1$ pebbles
on the graph of an exchange $\msc_0$,
where initially there are (at most) $n$ pebbles
placed on the first event of each machine and also (at most) $n$ pebbles placed
on the last event of each machine. Eve also places (at most) $n$ pebbles on the last
send event of each machine and also (at most) $n$ pebbles on the first receive event of
each machine. Eve erases the (at most) $n$ $\procrel$-edges between the last send event and the first receive event.

We are now in a configuration that will be our invariant.
Let us fix a linearisation of $\msc_0$
and let $e$ be the first send event in this linearisation.
\begin{itemize}
\item if $e$ is an unmatched send of process $p$,
Eve places her last pebble on the next
send event of $p$ (if it exists), let us call it $e'$. Then Eve erases the
$\procrel$ edge $(e,e')$, and now $e$ is completely disconnected,
so it can be removed and the pebble can be taken back.
\item if $e\lhd e'$, with $e'$ a receive event of process $q$,
then due to the mailbox semantics $e'$ is the first receive event of $q$,
so it has a pebble placed on it. Eve removes the $\lhd$ edge between
$e$ and $e'$, then using the extra pebble she disconnects $e$ and places a
pebble on the $\procrel$ successor of $e$, then she also
disconnects $e'$ and places a pebble of the $\procrel$ successor of $e'$.
\end{itemize}
After that, we are back to our invariant, so we can repeat the same
strategy with the second send event of the linearisation, and so on until
all edges have been erased.
\end{proof}


By Theorems~\ref{mailbox} and \ref{thm:sync}, we obtain the following result as a corollary.
Note that it assumes the mailbox semantics.

\begin{theorem}\label{thm:mailbox-weak-sync}
The following problem is decidable in exponential time:
Given $\Procs$, $\Msg$, and a communicating system $\System$ (over $\Procs$ and $\Msg$), is every MSC in $\mbL{\System}$ weakly synchronous?
\end{theorem}

\begin{proof}
For the given $\Procs$ and $\Msg$, we determine the LCPDL formula $\Phi_\mathsf{wsmb}$ such
that $L(\Phi_\mathsf{wsmb})$ is the set of weakly synchronous mailbox MSCs. Moreover,
recall from Proposition~\ref{prop:new-weak-logic-bounded} that
the special tree-width of all weakly synchronous mailbox MSCs is bounded by
$4|\Procs|$.

By Lemma~\ref{lem:continuous}, we have
$\mbL{\System} \subseteq L(\Phi_\mathsf{wsmb})$ iff
$\mbL{\System} \cap \stwMSCs{(4|\Procs|+2)} \subseteq L(\Phi_\mathsf{wsmb})$.
The latter is an instance of the bounded model-checking problem.
As the length of $\Phi_\mathsf{wsmb}$ is linear in
$|\Procs|$, we obtain that the original problem is decidable
in exponential time by Theorem~\ref{mailbox}.
\end{proof}

For the same reasons, the bounded model-checking problem for weakly
synchronous systems is decidable.
%
Interestingly, a reduction from Post's correspondence problem
shows that decidability fails when adopting the p2p semantics:

\begin{restatable}{theorem}{ppweaksynch}\label{thm:p2p-weak-sync}
The following problem is undecidable:
Given finite sets $\Procs$ and $\Msg$ as well as a communicating system $\System$,
is every MSC in $\ppL{\System}$ weakly synchronous?
\end{restatable}


\subsection{Weakly $k$-Synchronous MSCs}\label{sec:weakly-k}

This negative result for the p2p semantics motivates the study of other classes.
In fact, our framework captures several classes introduced in the literature.

\begin{definition}[$k$-exchange]\label{def:weak-synchr}
Let $\msc = (\Events,\procrel,\lhd,\lambda)$ be an MSC
and $k \in \N$.
We call $\msc$ a $k$-\emph{exchange} if
$\msc$ is an exchange and $|\SendEv{\msc}| \le k$.
\end{definition}


Let us now recall the definition
from \cite{DBLP:conf/cav/BouajjaniEJQ18,DBLP:conf/fossacs/GiustoLL20}, but (equivalently)
expressed directly in terms of MSCs rather than via \emph{executions}. This differs from the weakly synchronous MSCs in that here, we insist on constraining the number of messages sent per exchange to be at most $k$.

\begin{definition}[weakly $k$-synchronous]\label{def:weaksync}
Let $k \in \N$.
We say that $\msc \in \MSCs$ is
weakly $k$-synchronous if it is of the form
$\msc = \msc_1 \cdot \ldots \cdot \msc_n$
such that every $\msc_i$ is a $k$-exchange.
\end{definition}

\noindent \begin{minipage}[c]{10.5cm}
\begin{example}
MSC $\msc_3$ in Fig.~\ref{fig:msc_weak_S_exist} is weakly $1$-synchronous, as it can be
decomposed  into three \kE{1}s (the decomposition is depicted by the
horizontal dashed lines). We remark that $\msc_3 \in
\mbMSCs$. Note that there is a p2p linearization that respects the decomposition.
On the other hand, a mailbox linearization needs to reorganize actions from different MSCs: the sending of
$\msg_3$ needs to be done before the sending of $\msg_1$. Note that $\msc_1$ in
Fig.~\ref{fig:msc_weak_univer} is also weakly $1$-synchronous.
\end{example}
\end{minipage}
\hfill
\begin{minipage}[c]{3cm}
\begin{center}

\begin{tikzpicture}[>=stealth,node distance=3.4cm,shorten >=1pt,
    every state/.style={text=black, scale =0.7}, semithick,
    font={\fontsize{8pt}{12}\selectfont}, scale = 0.8]

  %MACHINES
  \draw (0,0) node{$p$} ;
  \draw (1,0) node{$q$} ;
  \draw (2,0) node{$r$} ;
  \draw (0,-0.25) -- (0,-3.5) ;
  \draw (1,-0.25) -- (1,-3.5);
  \draw (2, -0.25) -- (2, -3.5) ;
  %MESSAGES
  \draw[>=latex,->, dashed] (0,-0.75) -- (1, -0.75) node[midway,above]{$\amessage_1$};

  \draw[>=latex,->] (1, -1.75) -- (0, -1.75) node[midway, above] {$\amessage_2$};
  %\draw (0.5,-1.7) node{$\cdots$};
  %\draw[>=latex,->] (1, -2.25) -- (0, -2.25) node[midway, above] {$\amessage_2$};

  \draw[>=latex,->] (2,-2.75) -- (1,-2.75) node[midway, above] {$\amessage_3$};
%\end{scope}
  \draw[dashed] (-0.5,-1.25) -- (2.5,-1.25) ;
  \draw[dashed] (-0.5,-2.25) -- (2.5,-2.25) ;


\end{tikzpicture}
\captionof{figure}{MSC $\msc_3$}
\label{fig:msc_weak_S_exist}

\end{center}
\end{minipage}

\medskip


\begin{restatable}{proposition}{weaklogicstw}
	\label{prop:weak-logic-bounded}
Let $k \in \N$. The set of weakly $k$-synchronous p2p (mailbox, respectively) MSCs
is MSO-definable. Its special tree-width is bounded by
$2k + |\Procs|$.
\end{restatable}


In fact, Proposition~\ref{prop:weak-logic-bounded} essentially follows from the following known theorem:

\begin{theorem}[\cite{DBLP:conf/fossacs/GiustoLL20}] \label{th:scccharactweak}
	Let $M$ be a MSC. Then, $M$ is weakly $k$-synchronous iff every SCC in its conflict graph is of size at most $k$ and if no RS edge occurs on any cyclic path.
\end{theorem}

This property is similar to the graphical characterization of weakly synchronous MSCs, except  for the condition that every SCC in the conflict graph is of size at most $k$.
Furthermore, it is easy to show that the family $\Sync_k$ has bounded special tree-width:

\begin{restatable}{proposition}{kweakstw}
\label{prop:kweakstw}
	Let $k \geq 1$. The set of MSCs that are weakly $k$-synchronous have special tree-width bounded by $2k+|\Procs|$.
\end{restatable}

Hence, we can conclude that $\Sync_k$ is MSO-definable and STW-bounded.
As a corollary, we get the following (known) decidability result, but via an alternative proof:

\begin{theorem}[\cite{DBLP:conf/cav/BouajjaniEJQ18,DBLP:conf/fossacs/GiustoLL20}]\label{thm:weak-sync}
For $\comsymb \in \{\ppsymb, \mbsymb\}$, the following problem is decidable:
Given finite sets $\Procs$ and $\Msg$, a communicating system $\System$, and $k \in \N$,
is every MSC in $\cL{\System}$ weakly $k$-synchronous?
\end{theorem}


\begin{proof}
We proceed similarly to the proof of Theorem~\ref{thm:mailbox-weak-sync}.
%
For the given $\Procs$, $\Msg$, and $k$, we first determine the LCPDL formula $\Phi_k$ such
that $L(\Phi_k)$ is the set of weakly $k$-synchronous mailbox MSCs. From
Proposition~\ref{prop:weak-logic-bounded}, we know that
the special tree-width of all weakly $k$-synchronous mailbox MSCs is bounded by
$2k + |\Procs|$.

By Lemma~\ref{lem:continuous}, we can reduce completeness to bounded model checking, obtaining
$\cL{\System} \subseteq L(\Phi_\mathsf{wsmb})$ iff
$\cL{\System} \cap \stwMSCs{(2k + |\Procs| + 2)} \subseteq L(\Phi_\mathsf{wsmb})$.
The latter is an instance of the bounded model-checking problem.
By Fact~\ref{p2p} and Theorem~\ref{mailbox}, we obtain decidability in exponential time.
\end{proof}

\begin{remark}
The set of weakly $k$-synchronous MSCs is not directly expressible in LCPDL
(the reason is that LCPDL does not have a built-in counting mechanism).
However, its \emph{complement} is expressible in the extension EQ-LCPDL of LCPDL with
existentially quantified proposition \cite{DBLP:journals/corr/abs-1904-06942} (we need $k+1$ of them). The model-checking problem for
this kind of property is still in EXPTIME and, therefore, so is the problem from
Theorem~\ref{thm:weak-sync}. It is very likely that our approach can also be used to
infer the optimal PSPACE upper bound from \cite{DBLP:conf/cav/BouajjaniEJQ18}
by showing bounded \emph{path width} and using finite word automata instead of tree automata.
Finally, note that
the problem to decide whether there exists an integer $k \in \N$ such that  $\cL{\System} \subseteq \Class_k$ has been studied in another paper \cite{}.
\end{remark}

%\bigskip
%
%\noindent
%\begin{minipage}[c]{10cm}
%	\begin{example}
%	MSC $\msc_4$ in Fig.~\ref{fig:msc_W_S} is strongly synchronous. Indeed, repetitions of  messages $\amessage_1$ and $\amessage_2$ are interlaced and form an exchange. So, the division into exchanges is consistant with the partial order imposed by the mailbox communication. However, if we consider $\msc_2$ in Fig.~\ref{fig:msc_W}, which is weakly-synchronous, we can see that it is not strongly synchronous, as the decomposition as described in Example~\ref{example:msc_W}, does not correspond to the partial order: $\amessage_1$ has to be sent after $\amessage_5$ as this last one is matched and $\amessage_1$ is not (within mailbox communication).
%	\end{example}
%\end{minipage}
%\hfill
%\begin{minipage}[c]{3cm}
%\begin{center}
%  \begin{tikzpicture}[>=stealth,node distance=3.4cm,shorten >=1pt,
%  every state/.style={text=black, scale =0.7}, semithick,
%    font={\fontsize{8pt}{12}\selectfont}]
%
%\begin{scope}[shift = {(8,0.75)}, scale = 0.8]
%%	\draw (0.75, -4) node{\textbf{(b)}};
%  %MACHINES
%  \draw (0,0) node{$p$} ;
%  \draw (1.5,0) node{$q$} ;
%  \draw (0,-0.25) -- (0,-3.5) ;
%  \draw (1.5,-0.25) -- (1.5,-3.5);
%  %MESSAGES
%
%  \draw[>=latex,->] (0, -0.7) -- (1.5, -1.8) node[pos=0.2, sloped, above] {$\amessage_1$};
%  \draw[>=latex,->] (0, -1.4) -- (1.5, -2.5) node[pos=0.1, sloped, above] {$\amessage_1$}; %{$\amessage_1'$};
%  %\draw[>=latex,->, dashed] (0, -2.5) -- (1.25, -3.25) node[pos=0.55, sloped, above] {$\amessage_1''$};
%
%  \draw[>=latex,->] (1.5, -0.5) -- (0, -2.2) node[pos=0.1, sloped, above] {$\amessage_2$};
%  \draw[>=latex,->] (1.5, -1.2) -- (0, -2.9) node[pos=0.05, sloped, above] {$\amessage_2$};
%  % \node[rotate = 90, left]at (1.13, -0.65) {$\cdots$};
%  % \node[rotate = -90, right]at (0.1, -0.65) {$\cdots$};
%
%\end{scope}
%
%\end{tikzpicture}
%\captionof{figure}{MSC $\msc_4$}
%\label{fig:msc_W_S}
%\end{center}
%
%\end{minipage}
%
%


\section{Relations Between Classes}\label{section:comparison}



In this section we study how the classes introduced and recalled so far are related to each other. Notably, depending on the semantics (\pp or mailbox) we obtain two different classifications. The results are summed up in Figs. \ref{fig:diagram_p2p} and \ref{fig:diagram_mailbox_all}.
To refer to those systems we use the following terminology:
a system $\System$ is called
\wS{} (resp. \sS{}) if, for all MSCs $\msc$, there is a $k$ such that $\msc$ is \wkSo{k} (resp. \skSo{k});
a system is called \wks{k} (resp. \sks{k}, \eb{} or \ub{})
if there is a $k$ such that all MSCs are \wkSo{k} (resp. \skSo{k}, \ekb{k} or \ukb{k}).

A similar comparison relating existentially bounded systems, \wks{k} systems, as well as other systems that have not been described here, can also be found in \cite{DBLP:journals/corr/abs-1901-09606} for \pp systems. We first adapt the definition of \skSo{k} MSCs to \pp.

\begin{definition}
	Let $\msc = (\Events,\procrel,\lhd,\lambda) \in \MSCs$.
	We say that $\msc$ is \emph{strongly $k$-synchronous}
	if it is of the form
	$\msc = \msc_1 \cdot \ldots \cdot \msc_n$ (with $\msc_i$ an MSC)
	such that every $\msc_i = (\Events_i,\procrel_i,\lhd_i,\lambda_i)$ is a $k$-exchange
	and, for all $(e,f) \in {\le}_\msc$, there are indices $1 \le i \le j \le n$
	such that $e \in \Events_i$ and $f \in \Events_j$.
\end{definition}



\begin{figure}[h]
	\begin{center}

\begin{tikzpicture}[scale = 0.5, opacity = 0.7]
	\draw[rounded corners = 5pt, gray!80, fill=gray!20]  (-2.5,3) rectangle (10.5,7);
	\draw[rounded corners = 5pt, gray!85, fill=gray!40]  (-1,3) rectangle (20,6);
		\draw[rounded corners = 5pt, gray!95, fill= gray!60]  (1,3) rectangle (10.5,5.5);
		\draw[rounded corners = 5pt, gray!90, fill = gray!70]  (9,3) rectangle (17,5);

		\draw (-2.3,6.5) node[right]{\textbf{Weakly/Strongly synchronizable}};
		\draw (19.8,5.5) node[left]{\textbf{Existentially bounded}};
		\draw (16.8,4.5) node[left]{\textbf{Universally}};
		\draw (16.8,4) node[left]{\textbf{bounded}};
		\draw (1.2,5) node[right]{\textbf{Weakly/Strongly }};
		\draw (1.2,4.4) node[right]{\textbf{k-synchronizable}};
	%	\draw (1.2,3.8) node[right]{\textbf{}};

		\tikzstyle{vertex}=[draw,circle,fill=black, minimum size = 3pt, inner sep = 0pt]

	%	\draw (4.2,3) node[vertex, label = left:{$\System_6$}] (v) {};
	%	\draw (7.5,2.5) node[vertex, label = above left:{$\System_7$}] (v) {};
		\draw (18.5,3.8) node[vertex, label = above :{$\System_6$}] (v) {};
		\draw (12,3.8) node[vertex, label = above :{$\System_8$}] (v) {};

		\draw (9.8,3.8) node[vertex, label = above :{$\System_1$}] (v) {};
		\draw (8.3,3.8) node[vertex, label =  above:{$\System_3$}] (v) {};
		\draw (0,3.8) node[vertex, label =  above:{$\System_7$}] (v) {};
		\draw (-1.7,3.8) node[vertex, label =  above:{$\System_4$}] (v) {};

	%	\draw (4.7,1.5) node[vertex, label =  left:{$\System_4$}] (v) {};

\end{tikzpicture}
\caption{Hierarchy of classes for \pp systems}
\label{fig:diagram_p2p}

\end{center}
\end{figure}


\begin{figure}[h]
	\begin{center}

\begin{tikzpicture}[scale = 0.5, opacity = 0.7]

	\draw[rounded corners = 5pt, gray!75, fill=gray!20]
  (-2,0) rectangle (15,6.5);
  \draw[rounded corners = 5pt, gray!95, fill=gray!40]
  (5,0) rectangle (22,6);
  \draw[rounded corners = 5pt, gray!90, fill=gray!30]
  (-1.5,0) rectangle (15,3);
  \draw[rounded corners = 5pt, gray!90, fill=gray!50]
  (3,1) rectangle (15,4.5);
  \draw[rounded corners = 5pt, gray!95, fill=gray!60]
  (7,1) rectangle (15,2.5);
  \draw[rounded corners = 5pt, gray, fill=gray!70]
  (13,0) rectangle (21,2);


	 \draw (-1.8,6) node[right]{\textbf{Weakly }};
	 \draw (-1.8,5.4) node[right] {\textbf{synchro.}};
   \draw (21, 5.5) node[left] {\textbf{Existentially }} ;
  \draw (21.8, 4.9) node[left] {\textbf{ bounded}};
   \draw (-1.3, 2.5) node[right] {\textbf{Weakly }};
   \draw (-1.3, 1.9) node[right] {\textbf{k-synchro.}};
   \draw (14.8, 4) node[left] {\textbf{Strongly}};
   \draw (14.8, 3.4) node[left] {\textbf{synchro.}};
   \draw (7.2, 2) node[right] {\textbf{Strongly}};
     \draw (7.2, 1.4) node[right] {\textbf{k-synchro.}};
   \draw (20.8, 1.5) node[left] {\textbf{Universally }};
   \draw (20.8, 0.9) node[left] {\textbf{bounded}};



	\tikzstyle{vertex}=[draw,circle,fill=black, minimum size = 3pt, inner sep = 0pt]
	\draw (0,3.8) node[vertex, label = right :{$\System_2$}] (v) {};
	\draw (0,0.5) node[vertex, label = right :{$\System_9$}] (v) {};
	\draw (3.5,3.8) node[vertex, label = right :{$\System_4$}] (v) {};
	\draw (3.5,1.5) node[vertex, label = right :{$\System_{13}$}] (v) {};
	\draw (5.5,1.5) node[vertex, label = right :{$\System_3$}] (v) {};
	\draw (8,0.5) node[vertex, label = right :{$\System_{11}$}] (v) {};
	\draw (8,5.3) node[vertex, label = right :{$\System_{10}$}] (v) {};
	\draw (8,3.8) node[vertex, label = right :{$\System_7$}] (v) {};
	\draw (11.5,1.5) node[vertex, label = right :{$\System_5$}] (v) {};
	\draw (13.4,1.5) node[vertex, label = right :{$\System_{12}$}] (v) {};
	\draw (13.4,0.5) node[vertex, label = right :{$\System_{1}$}] (v) {};
	\draw (16,3.8) node[vertex, label = right :{$\System_6$}] (v) {};
	\draw (16,0.5) node[vertex, label = right :{$\System_8$}] (v) {};

\end{tikzpicture}
 \caption{Hierarchy of classes for mailbox systems}
\label{fig:diagram_mailbox_all}

\end{center}
\end{figure}



Systems cited as examples are available in Appendix~\ref{appendix:comparison}.
We can refind in those diagrams some properties (proofs are available in Appendix~\ref{appendix:comparison}):

\begin{restatable}{proposition}{strongequalweakptop}
\label{proposition:strong_equal_weak_p2p}
	A \pp MSC is \skSo{k} iff it is \wkSo{k}.
\end{restatable}


\begin{restatable}{proposition}{synchroinexists}
  \label{proposition:synchro_in_exists}
	Every \skSo{k}  \pp (resp. mailbox) MSC is existentially $k$-p2p-bounded (resp. existentially $k$-mailbox-bounded).
\end{restatable}

\begin{restatable}{proposition}{weakuniveruweak}
  \label{proposition:weak_univer_uweak}
  Every weakly (resp. strongly) synchronizable and \ukb{k} system is weakly (resp. strongly) $k'$-synchronizable for a $k'$.
\end{restatable}


\paragraph*{Send-synchronizability.}
 In \cite{DBLP:conf/www/BasuB11,DBLP:conf/popl/BasuBO12}, Basu et al. studied the \emph{synchronizability} property defined as: a system $\System$ is \emph{synchronizable} if every execution is equivalent (in terms of the projection on sending messages) to the same system $\System$ but communicating by rendezvous. To avoid ambiguity, we call such systems \emph{send-synchronizable}.
The class of weakly $1$-synchronizable systems is incomparable with the class of send-synchronizable systems.
However, with an additional hypothesis about the set of reachable configurations, a weakly $1$-synchronizable system is send-synchronizable.
Let us say that a system is \emph{stabilising} (called deadlockfree in \cite{DBLP:journals/iandc/LohreyM04}) if from any reachable configuration it can reach a confi\-gu\-ration with empty buffers (this is a stable configuration). Then every weakly $1$-synchronizable and stabilising system is send-synchronizable. Let us argue why the send-synchronizability does not fit in our framework.
 If send-synchronizability would be captured by our logical framework, then in particular, the question $\ppL{\Sys} \subseteq \Class_0$ would be decidable (by Theorem \ref{k-synchro}), where $\Class_0$ is the set of send-synchronizable MSCs. But this property is equivalent to checking whether the system $\System$ is send-synchronizable (since we are checking if every linearization does indeed correspond to the send projection of a rendezvous run), which was shown to be undecidable in \cite{DBLP:conf/icalp/FinkelL17}.


\section{Conclusion and Perspectives}
We have presented a unifying framework based on MSO logic and (special) tree-width, that brings together existing definitions, explains their good properties, and allows one to easily derive other, more general definitions and decidability results for synchronizability.

Many other related questions could be studied in the future. For example, we could think about the hypotheses to add to our general framework to make the problem \emph{``does there exist an $k \geq 0$ such that $\ppL{\Sys} \subseteq \Class_k$?''}  decidable. From very recent and unpublished research, one knows that the problem \emph{``does there exist an $k \geq 0$ such that the system is (weakly/strongly) $k$-synchronizable?"} is decidable; but it remains to be seen if it would be possible to obtain these results by showing that these properties can be expressed in a decidable extension of our framework. Let us remark that the decidability of the question whether there exists an $k \geq 0$ such that $\ppL{\Sys} \subseteq \Class_k$ allows us to build a bounded model checking strategy by first deciding whether there exists such an $k \geq 0$ and then by testing if $\ppL{\Sys} \subseteq \Class_k$ for $k=0,1,2 \dots$.
One may use this strategy for weakly/strongly synchronizable systems, but not for existentially bounded systems (except for deadlock-free systems) nor for deterministic deadlock-free universally bounded systems. One may also analyse the complexity of the studied problems and to get better complexity, one could use logic ICPDL instead of MSO logic.
 In \cite{DBLP:journals/corr/abs-1901-09606}, Lange and Yoshida introduced an \emph{asynchronous compatibility} property and it would also be interesting to verify whether this property could be expressed into our framework.






\bibliography{biblio}
\clearpage
\appendix

\section{Proof for Section 2}

\subsection{Proof of Lemma~\ref{lem:mb-prefix}}
\label{app:mb-prefix}

\prefixmailbox*

\begin{proof}
	Let $\msc = (\Events, \procrel, \lhd, \lambda) \in \mbMSCs$ and $\msc_0 =
	(\Events_0, \procrel_0, \lhd_0, \lambda_0)$ be a prefix of $\msc$, i.e.,
	$\Events_0 \subseteq \Events$. By contradiction, suppose that $\msc_0$ is not a
	mailbox MSC. Then, there are distinct $e,f \in \Events_0$ such that $e \preceq_{M_0} f \preceq_{M_0}
	e$ with ${\preceq_{\msc_0}} = ({\rightarrow_0} \cup {\lhd_0} \cup {\mbrel_{\msc_0}})^*$.
	As $\Events_0 \subseteq \Events$, we have that ${\rightarrow_0} \subseteq {\rightarrow}$, ${\lhd_0} \subseteq {\lhd}$, and ${\mbrel_{\msc_0}} \subseteq {\mbrel_{\msc}}$. Finally, ${\preceq_{\msc_0}} \subseteq {\preceq_{\msc}}$ and $\msc$ is not a mailbox MSC, which is a contradiction.
\end{proof}






\section{Proofs for Section 3}

\subsection{Proof of Theorem~\ref{mailbox}}
\label{app:mailbox}

\boundedmc*

\begin{proof}
Using the mailbox semantics and the MSO formula $\mbformula$, we get
\[\begin{array}{rl}
 &\mbL{\System} \cap \stwMSCs{k} \subseteq L(\phi)\\[1ex]
 \Longleftrightarrow &\ppL{\System} \cap \stwMSCs{k}\cap L(\mbformula)  \subseteq L(\phi)\\[1ex]
 \Longleftrightarrow &\ppL{\System} \cap \stwMSCs{k} \subseteq L(\phi \vee \neg \mbformula)\,.
\end{array}\]
The latter is decidable due to Fact~\ref{p2p}.
Similarly, we can use the LCPDL formula $\mbFormula$, whose size is polynomial in the number of processes and messages.
\end{proof}



\subsection{Proof of Lemma~\ref{lem:continuous2}}
\label{app:continuous2}

\lemcontinuoustwo*

\begin{proof}
	Let $k$ and $\Class$ be fixed, and let
	$\msc\in \MSCs\setminus \Class$ be fixed.
	Let $\msc'\in \Pref{\msc}$ be such that $\Pref{\msc'}\subseteq L\cup\{\msc'\}$
	(in other words, $\msc'$ is the shortest prefix of $\msc$ that is in $\MSCs\setminus \Class$.
	Let $\leq$ be a linearisation of $\msc'$, let $e$ be the last event
	of $\msc'$ wrt $\leq$, and let $\msc''=\msc'\setminus\{e\}$.
	Note that this event
	$e$ exists unless $\msc'$ is the empty MSC, but in this degenerated case
	$\msc'\in (\Pref{\msc}\cap\stwMSCs{k+2})\setminus \Class$ and the proof
	is finished.

	Since $\msc'$ was taken minimal in terms of number of events,
	$\msc''\in \Class$.
	So Eve has a winning strategy with $k+1$ pebbles for $\msc''$.
	Let us design a winning strategy with $k+3$ pebbles for Eve for $\msc'$, which
	will show the claim.

	Observe that the event $e$ occurs at the end of the timeline of a process (say $p$), and it is part of at most two edges:
	\begin{itemize}
		\item one with the previous $p$-event (if any)
		\item one with the corresponding send event (if $e$ is a receive event)
	\end{itemize}
	Let $e_1,e_2$ be the two neighbours of $e$.
	The strategy of Eve is the following: in the first round, mark $e,e_1,e_2$,
	then erase the edges $(e_1,e)$ and $(e_2,e)$, then split the remaining graph
	in two parts: $\msc''$ on the one side, and the single node graph $\{e\}$ on
	the other side. Then Eve applies its winning strategy for $\msc''$, except
	that initially the two events $e_1,e_2$ are marked (so she may need up to $k+3$
	pebbles).
\end{proof}



\section{Proofs for Section~4}

\subsection{Proof of Proposition~\ref{prop:newweaklogiccg}}

\newweaklogiccg*

\begin{proof}
	$\implies$ Let $\msc$ be an MSC. If $\msc$ is weakly synchronous, then $\msc = \msc_1 \cdot \ldots \cdot \msc_n$ such that every $\msc_i$ is an exchange. Hence, for every vertex $v$ of the conflict graph, there is exactly one index $\iota(v) \in \{1,\ldots,n\}$ such that $\exists \lambda^{-1}(e) \in \msc_{\iota(v)}$, where $e \in Send(\plh, \plh, v)$. Note that if there is an edge from $v$ to $v'$ in the conflict
	graph, some action of $v$ must happen before some action of $v'$, i.e., $\iota(v) \leq \iota (v')$.
	 Furthermore, note that if $v \xrightarrow{RS} v'$ , then $\iota(v) < \iota(v')$, since within an exchange all the sends precede all the receives. So an RS edge cannot occur on a cyclic path.

	$\impliedby$ Let $\msc$ be an MSC. We assume now that the conflict graph of $\msc$ does not contain a cyclic path with an RS edge. Let $V_1, \ldots , V_n$ be the set of maximal SCCs of the conflict graph, listed in some
	topological order. For a fixed $i$, let $M_i = s_1 \ldots s_m r_1 \ldots r_{m'}$ be the enumeration of
	the actions of the message exchanges of $V_i$ defined by first taking all send actions
	of $V_i$ obeying the relation $\leq_M$, and then all the receive actions of
	$V_i$ in the same order as in $\leq_M$. Let $M' = M_1 \ldots M_n$. Then the conflict graph of $M'$ is the same as that of $M$, as the permutation of actions we defined could only postpone a receive after a send of a same SCC, therefore it could only replace some $v \xrightarrow{RS} v'$ edge with an $v \xrightarrow{SR} v'$ edge between two vertices $v,v'$ of a same SCC. However, since we assumed that the cycles (hence by extensions SCCs) do not contain RS edges, this cannot happen. Therefore $M$ and $M'$ have the same conflict graph, and correspond to the same MSC. Furthermore, since each $M_i$ is a downward-closed set, $M'$ is weakly synchronous, and so is $M$.
\end{proof}



\subsection{Proof of Corollary~\ref{cor:weak-sync-lcpdl}}

\weaksynclcpdl*

\begin{proof}
LCPDL can be used to express the graphical characterization of weakly synchronous MSCs. This follows from the below formulas:
\begin{align*}
	\xrightarrow{SS} & = \test{\neg R} \cdot (\procrel)^+ \cdot \test{\neg R} \\
	\xrightarrow{RR} & = \test{\neg R} \cdot \lhd \cdot (\procrel)^+ \cdot \inv{\lhd} \cdot \test{\neg R} \\
	\xrightarrow{RS} & = \test{\neg R} \cdot \lhd \cdot (\procrel)^+ \cdot \test{\neg R} \\
	\xrightarrow{SR} & = \test{\neg R} \cdot (\procrel)^+ \cdot \inv{\lhd} \cdot \test{\neg R} \\
	\xrightarrow{CG} & = (\xrightarrow{SS} + \xrightarrow{RR} + \xrightarrow{RS} + \xrightarrow{SR})
\end{align*}

The absence of RS edges in any cycle in the conflict graph can be expressed by the following formula:
\[
\Phi_{wsync} = \neg \Loop{(\xrightarrow{CG})^*\cdot \xrightarrow{RS} \cdot (\xrightarrow{CG})^*}
\qedhere
\]
\end{proof}


\subsection{Proof of Theorem~\ref{thm:p2p-weak-sync}}
\label{app:p2p-weak-sync}

\ppweaksynch*

\begin{proof}
We show that the control state reachability problem for p2p weak
synchronizable systems is not decidable. This immediately shows
that the model-checking problem for p2p weak synchronizable systems
is not decidable. With some extra coding, it also shows that the
membership problem (decide whether a given system is p2p weak synchronizable)
also is undecidable: indeed, it is enough to add a non weak
synchronizable behaviour after the control states for which reachability is
undecidable: the system will be not weak synchronizable iff the control
states are reached.

We reduce from Post correspondance problem (PCP).
Let us recall that a PCP instance consists of $N$ pairs $(u_i,v_i)$ of
finite words over $\Sigma$, and that PCP undecidability holds already for
$N=7$ and $\Sigma=\{0,1\}$. We let the set of messages be
$\{1,\dots,N\}\uplus\Sigma\uplus\{\sharp\}$, and we consider a system with
four machines: Prover1, Prover2, Verifier1, and Verifier2. We have
unidirectionnal communication channels from provers to verifiers,
so the system is weakly synchronous by construction.

Informally, the system works as follows:
\begin{itemize}
\item Prover1 guesses a solution $u_{i_1}\dots u_{i_m}$ of the PCP instance,
and Prover2 also guesses the same solution $v_{i_1}...v_{i_m}$.
\item Prover1 sends $u_{i_1}\dots u_{i_n}$ to Verifier1 and sends
simultaneously $i_1\dots i_m$ to Verifier2
\item Prover2 sends $v_{i_1}\dots v_{i_m}$ to Verifier1 and sends
simultaneously $i_1\dots i_m$ to Verifier 2
\item Verifier1 checks that the two words are equal and Verifier2 checks that the sequences of indices are equal.
\end{itemize}

Let us now formally define these machines.
We describe them with regular expressions. For $w=a_1\cdots a_n$,
we write $\mathit{send}^*(p,q,w)$ (resp $\mathit{rec}^*(p,q,w)$)
for $\send{p}{q}{a_1}\cdots \send{p}{q}{a_n}$ (resp $\rec{p}{q}{a_1}\cdots\rec{p}{q}{a_n}$). We abbreviate Prover1 as P1, Prover2 as P2, Verifier1 as V1, and Verifier2 as V2

\begin{itemize}
\item Prover1 is $$\big(\sum_{i=1}^N\send{P_1}{V_1}{i}\mathit{send}^*(P_1,V_2,u_i)\big)^+\send{P_1}{V_1}{\sharp}\send{P_1}{V_2}{\sharp}$$

\item Prover2 is $$\big(\sum_{i=1}^N\send{P_2}{V_1}{i}\mathit{send}^*(P_2,V_2,v_i)\big)^+\send{P_2}{V_1}{\sharp}\send{P_2}{V_2}{\sharp}$$

\item Verifier1 is $$\big(\sum_{i=1}^N\rec{P_1}{V_1}{i}\rec{P_2}{V_1}{i}\big)^*\rec{P_1}{V_1}{\sharp}\rec{P_2}{V_1}{\sharp}$$

\item Verifier2 is $$\big(\sum_{a\in\Sigma}\rec{P_1}{V_2}{a}\rec{P_2}{V_2}{a}\big)^*\rec{P_1}{V_2}{\sharp}\rec{P_2}{V_2}{\sharp}$$

\end{itemize}

It can be checked that all machines reach their own final
state if and only if the PCP instance has a solution.
\end{proof}


\subsection{Proof of Proposition~\ref{prop:weak-logic-bounded}}


\weaklogicstw*

\begin{proof}
The formula for the property that there is no strongly connected component of size greater than $k$ in the conflict graph is as follows:
\begin{equation*}
	\nexists e_1, \ldots, e_{k+1} .\; [\bigwedge_{i \neq j} \XYformula{CG^*}(e_i, e_j)]
	\qedhere
\end{equation*}
\end{proof}


\subsection{Proof of Proposition~\ref{prop:kweakstw}}


\kweakstw*

\begin{proof}
	Let $M$ be a $k$-synchronous MSC. By definition, we know that $\msc = \msc_1 \cdot \ldots \cdot \msc_m$
	such that every $\msc_i$ is a $k$-exchange.

	Eve's strategy is to mark the vertices belonging to the set $M_1$. Hence, she marks at most $2k$ vertices. We can remove the edges between these vertices. Let the new marked graph be $(G_r, U_r)$ where $r = |M_1|$, and $G_r$ the new graph (with the edges between marked vertices removed), and $U_r$ the set of marked vertices.

	Notice  that $|U_r| \leq 2k$. Furthermore, since every vertex corresponding to a send message in $U_r$ is either unmatched or matched with a reception in $U_r$ (by definition), we can be sure that there are no message edges between vertices of $U_r$ and any other vertex. Furthermore, we can also be sure that there are at most $n$ process edges between vertices in $U_r$ and vertices outside this set. Let us mark these $n$ vertices. We call these vertices $V_\ell$ and $\ell = n$. Let the new graph be $(G_\ell, U_r \cup V_\ell)$. Now, we see that there are no edges between any of the vertices in $U_r$ and any other vertex, i.e. all the vertices in $U_r$ are isolated. We can  divide the graph to consist of the vertices $U_r$ and $V \setminus U_r$ and the corresponding edges.

	Let the graph with vertices in $U_r$ be $(G_1, U_1)$. It consists of at most $2k$ isolated coloured vertices. Let the graph with vertices in $V \setminus U_r$ be $(G_2, U_2)$. We observe that $|U_2|=n$. Adam  trivially loses if he chooses $(G_1, U_1)$, hence, he has to choose $(G_2, U_2)$. Now, we mark the vertices corresponding to $M_2$, which are again, at most $2k$. We have two possibilities for each vertex in $U_2$, either they belong to the set $M_2$ or belong to another set $M_p$ where $p>2$. However, if they belong to $M_p$, we can be sure that there is no other event on the same process that belongs to $M_2$ - this is because it was the successor of some event in $M_1$. Hence, we see once again, that marking all the vertices in $M_2$ and the immediate successors along each process will result in marked vertices of size at most $2k + n$. And once again, we see that we can separate into graphs $(G_1', U_1')$ and $(G_2', U_2')$ such that every vertex in $U_1'$ is isolated, and $|U_1'| \leq 2k$. We do this for all $i \in [m]$, and hence, we can effectively use $2k +n$ colours. Therefore, set of MSCs over $n$ processes which are $k$-synchronous have bounded special tree-width.
\end{proof}

\section{Additional materials of Section~\ref{section:comparison}}\label{appendix:comparison}

\input{Appendix-Sec5/appendix-comparison}

\end{document}
